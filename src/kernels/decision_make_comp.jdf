extern "C" %{
/*
 * @copyright (c) 2023-2025     Saint Louis University (SLU)
 * @copyright (c) 2023-2025     Massachusetts Institute of Technology (MIT)
 * @copyright (c) 2023-2025     Nvidia Corporation
 * @copyright (c) 2018-2025     King Abdullah University of Science and Technology (KAUST)
 * @copyright (c) 2018-2023     The University of Tennessee and The University of Tennessee Research Foundation
 *                              All rights reserved.
 */

#include "hicma_parsec.h"

%}

// Input parameters for the decision making computation task
descA           [ type = "parsec_tiled_matrix_t*" ]  // Matrix descriptor for the tiled matrix
params_tlr      [ type = "hicma_parsec_params_t *" ] // TLR (Tile Low Rank) parameters containing precision decisions
new_decisions   [ type = "uint16_t *" ]              // Output array to store new precision decisions

// Task definition for computing precision decisions for each matrix tile
Task(m, n)

// Iterate over lower triangular matrix tiles (m >= n)
m = 0 .. descA->lmt-1  // Row index from 0 to number of tiles in rows - 1
n = 0 .. m             // Column index from 0 to current row (lower triangular)

: descA(m, n)  // Depend on the matrix tile at position (m,n)


BODY
{
    // Initialize new decision with current decision
    new_decisions[n*descA->lmt+m] = params_tlr->decisions[n*descA->lmt+m];

    /* Diagonal tiles are always computed in double precision (DP) */
    if( m == n ) { 
#if GENOMICS
        // For gene computation, use single precision on GPU
        params_tlr->decisions_gemm_gpu[n*descA->lmt+m] = MASK_FP32;
#else
        // For general computation, use double precision on GPU
        params_tlr->decisions_gemm_gpu[n*descA->lmt+m] = MASK_FP64;
#endif
        return PARSEC_HOOK_RETURN_DONE;
    }

    // Calculate scaling factor based on number of tiles
    double scalar_factore = (double)params_tlr->NT;
    
    // Determine precision decisions based on tile norm relative to global norm and tolerance
    // Each decision checks if the normalized tile norm is below the precision-specific threshold
    bool decision_hp_gpu = params_tlr->norm_tile[n*params_tlr->NT+m] * scalar_factore / params_tlr->norm_global  < params_tlr->fixedacc / EPS_HP_GPU;
    bool decision_hp = params_tlr->norm_tile[n*params_tlr->NT+m] * scalar_factore / params_tlr->norm_global  < params_tlr->fixedacc / EPS_HP; 
    bool decision_sp = params_tlr->norm_tile[n*params_tlr->NT+m] * scalar_factore / params_tlr->norm_global  < params_tlr->fixedacc / EPS_SP; 
    bool decision_fp8 = params_tlr->norm_tile[n*params_tlr->NT+m] * scalar_factore / params_tlr->norm_global  < params_tlr->fixedacc / EPS_FP8; 

    // Debug print statement (commented out)
    //printf("\n (%d, %d), params_tlr->norm_global:%f, tile norm:%f, res:%f %f %f %f\n", m, n, params_tlr->norm_global,  params_tlr->norm_tile[n*params_tlr->NT+m],
    //params_tlr->norm_tile[n*params_tlr->NT+m] * scalar_factore / params_tlr->norm_global, params_tlr->fixedacc / EPS_FP8, params_tlr->fixedacc / EPS_HP, params_tlr->fixedacc / EPS_SP);

    /* Make precision decisions based on current tile type */
    // Handle dense tile precision decisions (DP, SP, HP, FP8)
    if( IS_DENSE(m, n) ) {
        // Precision selection hierarchy: FP8 -> HP -> SP -> DP (if supported)
#if HAVE_FP8
        if( decision_fp8 ) {
            new_decisions[n*descA->lmt+m] = DENSE_FP8;
        }
#if HAVE_HP
        else if( decision_hp ) {
            new_decisions[n*descA->lmt+m] = DENSE_HP;
        } else if( decision_sp ) {
#else   
        if( decision_sp ) { 
#endif // HAVE_HP

#else
        // FP8 not supported, check HP and SP
#if HAVE_HP
        if( decision_hp ) {
            new_decisions[n*descA->lmt+m] = DENSE_HP;
        } else if( decision_sp ) { 
#else
        if( decision_sp ) { 
#endif // HAVE_HP

#endif // HAVE_FP8

            new_decisions[n*descA->lmt+m] = DENSE_SP;
        } else {
            // Fall back to highest precision based on build configuration
#if GENOMICS
            new_decisions[n*descA->lmt+m] = DENSE_SP;
#else
            new_decisions[n*descA->lmt+m] = DENSE_DP;
#endif
        }
    } else { 
        // Handle low-rank tile precision decisions
        if( decision_sp ) {
            new_decisions[n*descA->lmt+m] = LOW_RANK_SP;
        } else {
            new_decisions[n*descA->lmt+m] = LOW_RANK_DP;
        }
    }

    // GPU precision decisions for dense tiles only
    if( params_tlr->gpus > 0 && IS_DENSE(m, n) ) {
#if defined(PARSEC_HAVE_DEV_CUDA_SUPPORT)
        // CUDA-specific GPU precision selection
        if( decision_hp_gpu && ENABLE_TF16_A16_B16_C16_OP16 ) { 
            params_tlr->decisions_gemm_gpu[n*descA->lmt+m] = MASK_TF16_A16_B16_C16_OP16; 
            //printf("%d %d : %g %g\n", m, n, params_tlr->norm_tile[n*params_tlr->NT+m], params_tlr->norm_global);
        } else if( decision_hp ) { 
#elif defined(PARSEC_HAVE_DEV_HIP_SUPPORT)
        // HIP-specific GPU precision selection
        if( decision_hp ) {
#else
        // No GPU support
        if( 0 ) {
#endif
            params_tlr->decisions_gemm_gpu[n*descA->lmt+m] = MASK_TF16_A16_B16_C32_OP32; 
        } else if( decision_sp ) { 
            params_tlr->decisions_gemm_gpu[n*descA->lmt+m] = MASK_FP32; 
        } else {
            // Fall back to highest precision based on build configuration
#if GENOMICS
            params_tlr->decisions_gemm_gpu[n*descA->lmt+m] = MASK_FP32; 
#else
            params_tlr->decisions_gemm_gpu[n*descA->lmt+m] = MASK_FP64; 
#endif
        }
    }
}
END

extern "C" %{

/**
 * @brief Create a new taskpool for decision making computation
 * @param [in] A:    the tiled matrix data, already distributed and allocated
 * @param [in] params: TLR parameters containing precision decisions and tolerances
 * @param [in] new_decisions: output array to store new precision decisions
 * @return the parsec taskpool object to schedule
 */
parsec_taskpool_t*
parsec_decision_make_comp_New(parsec_tiled_matrix_t *A,
        hicma_parsec_params_t *params,
        uint16_t *new_decisions )
{
    parsec_taskpool_t* decision_make_comp_taskpool;
    parsec_decision_make_comp_taskpool_t* taskpool = NULL;

    // Create the taskpool for decision making computation
    taskpool = parsec_decision_make_comp_new( A, params, new_decisions );
    decision_make_comp_taskpool = (parsec_taskpool_t*)taskpool;

    return decision_make_comp_taskpool;
}

/**
 * @brief Destroy the decision making computation taskpool
 * @param [inout] taskpool: the parsec taskpool object to destroy
 */
void parsec_decision_make_comp_Destruct(parsec_taskpool_t *taskpool)
{
    parsec_decision_make_comp_taskpool_t *decision_make_comp_taskpool = (parsec_decision_make_comp_taskpool_t *)taskpool;
    parsec_taskpool_free(taskpool);
}

/**
 * @brief Main function to make precision decisions for all matrix tiles
 * @param [in] parsec: parsec context for task scheduling
 * @param [in] A: tiled matrix descriptor
 * @param [inout] params: TLR parameters containing decisions to be updated
 * @return 0 on success
 */
int hicma_parsec_decision_make_comp(parsec_context_t *parsec,
                         parsec_tiled_matrix_t *A,
                         hicma_parsec_params_t *params )
{
    parsec_taskpool_t *parsec_decision_make_comp = NULL;
    // Allocate array to store new precision decisions
    uint16_t *new_decisions = (uint16_t *)calloc( sizeof(uint16_t), A->lmt * A->lnt );
    
    // Create and schedule the decision making taskpool
    parsec_decision_make_comp = parsec_decision_make_comp_New( A, params, new_decisions );

    if( parsec_decision_make_comp != NULL ){
        parsec_context_add_taskpool(parsec, parsec_decision_make_comp);
        parsec_context_start(parsec);
        parsec_context_wait(parsec);
        parsec_decision_make_comp_Destruct(parsec_decision_make_comp);
    }

    // Reduce decisions across all MPI processes and update parameters
    MPI_Allreduce(MPI_IN_PLACE, new_decisions, A->lmt * A->lnt, MPI_UNSIGNED_SHORT, MPI_SUM, MPI_COMM_WORLD);
    memcpy( (void *)params->decisions, (void *)new_decisions, A->lmt * A->lnt * sizeof(uint16_t) ); 
    free( new_decisions );

    return 0;
}

%}
