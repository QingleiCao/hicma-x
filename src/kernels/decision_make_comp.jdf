extern "C" %{
/*
 * @copyright (c) 2023-2025     Saint Louis University (SLU)
 * @copyright (c) 2023-2025     Massachusetts Institute of Technology (MIT)
 * @copyright (c) 2023-2025     Nvidia Corporation
 * @copyright (c) 2018-2025     King Abdullah University of Science and Technology (KAUST)
 * @copyright (c) 2018-2023     The University of Tennessee and The University of Tennessee Research Foundation
 *                              All rights reserved.
 */

#include "hicma_parsec.h"

%}

// Input parameters for the decision making computation task
descA           [ type = "parsec_tiled_matrix_t*" ]  // Matrix descriptor for the tiled matrix
params_tlr      [ type = "hicma_parsec_params_t *" ] // TLR (Tile Low Rank) parameters containing precision decisions
new_decisions   [ type = "uint16_t *" ]              // Output array to store new precision decisions

// Task definition for computing precision decisions for each matrix tile
Task(m, n)

// Iterate over lower triangular matrix tiles (m >= n)
m = 0 .. descA->lmt-1  // Row index from 0 to number of tiles in rows - 1
n = 0 .. m             // Column index from 0 to current row (lower triangular)

: descA(m, n)  // Depend on the matrix tile at position (m,n)


BODY
{
    // Initialize new decision with current decision
    new_decisions[n*descA->lmt+m] = params_tlr->decisions[n*descA->lmt+m];

    /* Diagonal tiles are always computed in double precision (DP) */
    if( m == n ) { 
#if GENOMICS
        // For gene computation, use single precision on GPU
        params_tlr->decisions_gemm_gpu[n*descA->lmt+m] = MASK_FP32;
#else
        // For general computation, use double precision on GPU
        params_tlr->decisions_gemm_gpu[n*descA->lmt+m] = MASK_FP64;
#endif
        return PARSEC_HOOK_RETURN_DONE;
    }

    hicma_parsec_get_precision_tile(params_tlr, &new_decisions[n*descA->lmt+m], params_tlr->norm_tile[n*params_tlr->NT+m], m, n);
}
END

extern "C" %{

/**
 * @brief Create a new taskpool for decision making computation
 * @param [in] A:    the tiled matrix data, already distributed and allocated
 * @param [in] params: TLR parameters containing precision decisions and tolerances
 * @param [in] new_decisions: output array to store new precision decisions
 * @return the parsec taskpool object to schedule
 */
parsec_taskpool_t*
parsec_decision_make_comp_New(parsec_tiled_matrix_t *A,
        hicma_parsec_params_t *params,
        uint16_t *new_decisions )
{
    parsec_taskpool_t* decision_make_comp_taskpool;
    parsec_decision_make_comp_taskpool_t* taskpool = NULL;

    // Create the taskpool for decision making computation
    taskpool = parsec_decision_make_comp_new( A, params, new_decisions );
    decision_make_comp_taskpool = (parsec_taskpool_t*)taskpool;

    return decision_make_comp_taskpool;
}

/**
 * @brief Destroy the decision making computation taskpool
 * @param [inout] taskpool: the parsec taskpool object to destroy
 */
void parsec_decision_make_comp_Destruct(parsec_taskpool_t *taskpool)
{
    parsec_decision_make_comp_taskpool_t *decision_make_comp_taskpool = (parsec_decision_make_comp_taskpool_t *)taskpool;
    parsec_taskpool_free(taskpool);
}

/**
 * @brief Main function to make precision decisions for all matrix tiles
 * @param [in] parsec: parsec context for task scheduling
 * @param [in] A: tiled matrix descriptor
 * @param [inout] params: TLR parameters containing decisions to be updated
 * @return 0 on success
 */
int hicma_parsec_decision_make_comp(parsec_context_t *parsec,
                         parsec_tiled_matrix_t *A,
                         hicma_parsec_params_t *params )
{
    parsec_taskpool_t *parsec_decision_make_comp = NULL;
    // Allocate array to store new precision decisions
    uint16_t *new_decisions = (uint16_t *)calloc( sizeof(uint16_t), A->lmt * A->lnt );
    
    // Create and schedule the decision making taskpool
    parsec_decision_make_comp = parsec_decision_make_comp_New( A, params, new_decisions );

    if( parsec_decision_make_comp != NULL ){
        parsec_context_add_taskpool(parsec, parsec_decision_make_comp);
        parsec_context_start(parsec);
        parsec_context_wait(parsec);
        parsec_decision_make_comp_Destruct(parsec_decision_make_comp);
    }

    // Reduce decisions across all MPI processes and update parameters
    MPI_Allreduce(MPI_IN_PLACE, new_decisions, A->lmt * A->lnt, MPI_UNSIGNED_SHORT, MPI_SUM, MPI_COMM_WORLD);
    memcpy( (void *)params->decisions, (void *)new_decisions, A->lmt * A->lnt * sizeof(uint16_t) ); 
    free( new_decisions );

    return 0;
}

%}
