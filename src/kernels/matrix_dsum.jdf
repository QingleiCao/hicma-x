extern "C" %{
/**
 * @copyright (c) 2023-2025     Saint Louis University (SLU)
 * @copyright (c) 2023-2025     Massachusetts Institute of Technology (MIT)
 * @copyright (c) 2023-2025     Nvidia Corporation
 * @copyright (c) 2018-2025     King Abdullah University of Science and Technology (KAUST)
 * @copyright (c) 2018-2023     The University of Tennessee and The University of Tennessee Research Foundation
 *                              All rights reserved.
 **/

#include "hicma_parsec.h"

/**
 * @brief Compute sum of matrix elements with NaN/Inf detection
 * @param A Pointer to matrix data
 * @param mb Number of rows in the block
 * @param nb Number of columns in the block
 * @param lda Leading dimension of matrix A
 * @param m Row index of the tile (for error reporting)
 * @param n Column index of the tile (for error reporting)
 * @return Sum of all matrix elements
 */
static double parsec_matrix_sum_CORE (double *A, int mb, int nb, int lda, int m, int n) {
    double res = 0.0;
    int indicator_nan = 0;
    int indicator_inf = 0;
    for (int j = 0; j < nb; j++) {
        for (int i = 0; i < mb; i++) {
            // Check for NaN values
            if( isnan(A[j*lda+i]) ) {
                indicator_nan = 1;
            }
            // Check for infinite values
            if( isinf(A[j*lda+i]) ) {
                indicator_inf = 1;
            }
            res += A[j*lda+i]; 
        }
    }

    // Report NaN values if found
    if( 1 == indicator_nan ) {
        fprintf(stderr, "***** NAN ****** in ( %d %d )\n", m, n);
    }

    // Report infinite values if found
    if( 1 == indicator_inf ) {
        fprintf(stderr, "***** INF ****** in ( %d %d )\n", m, n);
    }

	return res;
}

%}

// TODO: make it general for MP (Mixed Precision)
descA            [ type = "parsec_tiled_matrix_t *" ]  /* Matrix descriptor */
descAr           [ type = "parsec_tiled_matrix_t *" aligned = descA ]  /* Rank matrix descriptor */
decisions        [ type = "uint16_t *" ]               /* Precision decision array */
sum              [ type = "double *" ]                 /* Sum accumulation array */

/**
 * @brief Read matrix tile and compute its sum
 * Reads a matrix tile and computes the sum of its elements,
 * handling both dense and low-rank representations
 */
Read(m, n)

m = 0 .. descA->lmt-1
n = 0 .. m 

: descA(m, n)

READ A <- descA(m, n)
READ Ar <- descAr(m, n)

WRITE D <- NEW
        -> D Sum(m, n)

BODY
{
    int nb = descA->mb;
    // Adjust number of columns for low-rank tiles
    if( LOW_RANK_DP == decisions[n*descA->lmt+m] || LOW_RANK_SP == decisions[n*descA->lmt+m] )
        nb = ((int *)Ar)[0] * 2;
    // Compute sum of matrix elements
    *((double *)D) = parsec_matrix_sum_CORE( A, descA->mb, nb, descA->mb, m, n );
    //printf("%d %d : %lf\n", m, n, *((double *)D));
}
END

/**
 * @brief Accumulate sum contributions from all tiles
 * Collects sum contributions from all matrix tiles and accumulates them
 */
Sum(m, n)

m = 0 .. descA->lmt-1
n = 0 .. m 

: descA(0, 0)

READ D <- D Read(m, n) 

BODY
{
	int tid = es->th_id;
	// Accumulate sum contribution from this tile
	sum[tid] += *((double *)D); 
}
END


extern "C" %{

/**
 * @brief Create a new matrix sum calculation taskpool
 * @param dcA Matrix descriptor
 * @param dcAr Rank matrix descriptor
 * @param decisions Precision decision array
 * @param sum Array to store sum contributions
 * @return the parsec object to schedule
 */
static parsec_taskpool_t*
parsec_matrix_dsum_New(parsec_tiled_matrix_t *dcA,
        parsec_tiled_matrix_t *dcAr,
        uint16_t *decisions,
        double *sum) 
{
    parsec_taskpool_t* matrix_dsum_taskpool;
    parsec_matrix_dsum_taskpool_t* taskpool = NULL;

    taskpool = parsec_matrix_dsum_new(dcA, dcAr, decisions, sum); 
    matrix_dsum_taskpool = (parsec_taskpool_t*)taskpool;

    // Set up arena for double precision datatype
    parsec_add2arena(&taskpool->arenas_datatypes[PARSEC_matrix_dsum_DEFAULT_ADT_IDX],
                            parsec_datatype_double_t, PARSEC_MATRIX_FULL,
                            1, 1, 1, 1,
                            PARSEC_ARENA_ALIGNMENT_SSE, -1 );

    return matrix_dsum_taskpool;
}

/**
 * @brief Destructor for matrix sum calculation taskpool
 * @param taskpool Pointer to the taskpool to destroy
 */
static void parsec_matrix_dsum_Destruct(parsec_taskpool_t *taskpool)
{
    parsec_matrix_dsum_taskpool_t *matrix_dsum_taskpool = (parsec_matrix_dsum_taskpool_t *)taskpool;
    // Remove arena for double precision datatype
    parsec_del2arena(&matrix_dsum_taskpool->arenas_datatypes[PARSEC_matrix_dsum_DEFAULT_ADT_IDX]);
    parsec_taskpool_free(taskpool);
}

/**
 * @brief Compute sum of all matrix elements
 * Calculates the sum of all elements in a tiled matrix, handling both
 * dense and low-rank representations based on precision decisions
 * 
 * @param parsec PaRSEC context
 * @param dcA Matrix descriptor
 * @param dcAr Rank matrix descriptor
 * @param decisions Precision decision array
 * @return Total sum of all matrix elements
 */
double hicma_parsec_matrix_dsum(parsec_context_t *parsec,
                         parsec_tiled_matrix_t *dcA,
                         parsec_tiled_matrix_t *dcAr,
                         uint16_t *decisions )
{
    parsec_taskpool_t *parsec_matrix_dsum = NULL;

    int nb_threads = parsec->virtual_processes[0]->nb_cores;
    double *sum = (double *)calloc( nb_threads, sizeof(double) );

    parsec_matrix_dsum = parsec_matrix_dsum_New(dcA, dcAr, decisions, sum); 

    if( parsec_matrix_dsum != NULL ){
        parsec_context_add_taskpool(parsec, parsec_matrix_dsum);
        parsec_context_start(parsec);
        parsec_context_wait(parsec);
        parsec_matrix_dsum_Destruct(parsec_matrix_dsum);
    }

    // Sum up contributions from all threads on the root process
    double total = 0.0; 
    int root = dcA->super.rank_of(&dcA->super, 0, 0);
    if( dcA->super.myrank == root ) {
        for( int i = 0; i < nb_threads; i++ )
            total += sum[i];
    }

    // Broadcast the total sum to all processes
    MPI_Bcast( &total, 1, MPI_DOUBLE, root, MPI_COMM_WORLD );

    free( sum );

    return total;
}

%}
