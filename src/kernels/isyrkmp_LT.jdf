extern "C" %{
/**
 * @copyright (c) 2023-2025     Saint Louis University (SLU)
 * @copyright (c) 2023-2025     Massachusetts Institute of Technology (MIT)
 * @copyright (c) 2023-2025     Nvidia Corporation
 * @copyright (c) 2018-2025     King Abdullah University of Science and Technology (KAUST)
 * @copyright (c) 2018-2023     The University of Tennessee and The University of Tennessee Research Foundation
 *                              All rights reserved.
 **/
#include "hicma_parsec.h"
%}

/* Mixed precision SYRK operation parameters */
uplo      [type = "dplasma_enum_t"]     /* Upper or lower triangular storage */
trans     [type = "dplasma_enum_t"]     /* Transpose operation on matrix A */
alpha     [type = "double"]             /* Scalar multiplier for A*A^T */
descA     [type = "const parsec_tiled_matrix_t*"]  /* Input matrix A descriptor */
beta      [type = "double"]             /* Scalar multiplier for matrix C */
descC     [type = "parsec_tiled_matrix_t*"]        /* Output matrix C descriptor */
inttype   [type = "int"]                /* Integer type for mixed precision (0=double, 8=int8) */
params_tlr   [ type = "hicma_parsec_params_t *" ]  /* HiCMA parameters for TLR operations */

/* GPU workspace and device management */
ws_gpu       [ type = "void *" hidden = on default = NULL ]  /* GPU workspace pointer */
nb_cuda_devices      [ type = "int"   hidden = on default = 0 ]     /* Number of CUDA devices */
cuda_device_index    [ type = "int *" hidden = on default = "NULL"] /* CUDA device indices array */

/**************************************************
 *               Define Arena                     *
 * Arena for managing mixed precision data types
 * Supports both double precision (DP) and 8-bit integer (I8)
 **************************************************/
my_arena(k)

// Execution space - single iteration for arena setup
k = 0 .. 0

// Parallel partitioning - reference to matrix C tile (0,0)
:descC(0, 0)

// Parameters - placeholders for both data types
READ A1 <- NULL       [ type = FULL_DP ]  /* Double precision data type */
READ A2 <- NULL       [ type = FULL_I8 ]  /* 8-bit integer data type */

BODY
{
    /* Arena initialization - no computation needed */
}
END

/**
 * Mixed precision SYRK (Symmetric Rank-K update) task for lower triangular matrices
 * Computes: C = alpha * A * A^T + beta * C
 * Supports both double precision and 8-bit integer precision with tensor core acceleration
 * 
 * @param n Row/column index of the diagonal block in matrix C
 * @param k Row index of the block in matrix A
 */
isyrk(n, k)
  /* Execution Space - iterate over all diagonal blocks of C and all rows of A */
  n = 0..(descC->nt-1)    /* All diagonal blocks of symmetric matrix C */
  k = 0..(descA->mt-1)    /* All row blocks of matrix A */

  /* Locality - computation is performed on the diagonal block (n,n) of C */
  : descC(n,n)

  /* Mixed precision data dependencies for SYRK operation */
  /* Input data type depends on inttype parameter and iteration */
  READ  A    <- ((k!=descA->mt-1) && (inttype == 8 )) ?  A isyrk_in_data_A0(n, k)           [type = FULL_I8]   /* 8-bit integer for tensor core */
             <- ((k!=descA->mt-1) && (inttype == 0 )) ?  A isyrk_in_data_A0(n, k)           [type = FULL_DP]   /* Double precision */
             <- ((k==descA->mt-1)) ?  A isyrk_in_data_A0(n, k)                              [type = FULL_DP]   /* Always double precision for last iteration */

  /* Output data type depends on inttype parameter and iteration */
  RW    C    <- ((0==k)) ? descC(n,n)                                                       /* First iteration: read from original C */
             <- ((k>=1)&& (inttype == 8 )) ? C isyrk(n, k-1)    [type = FULL_I8]           /* 8-bit integer intermediate results */
             <- ((k>=1) && (inttype == 0 )) ? C isyrk(n, k-1)   [type = FULL_DP]           /* Double precision intermediate results */
             -> ((descA->mt>=(2+k))&& (inttype == 8 )) ? C isyrk(n, k+1)          [type = FULL_I8]   /* Pass 8-bit integer to next iteration */
             -> ((descA->mt>=(2+k))&& (inttype == 0 )) ? C isyrk(n, k+1)          [type = FULL_DP]   /* Pass double precision to next iteration */
             -> ((descA->mt==(1+k))) ? descC(n,n)                                               /* Last iteration: write back to original C */

BODY [type=CUDA]
{
    /* Calculate actual block dimensions (handle edge cases for last blocks) */
    int tempnn = (n==(descC->nt-1)) ? (descC->n-(n*descC->nb)) : descC->nb;  /* Block size in C (n dimension) */
    int tempkm = (k==(descA->mt-1)) ? (descA->m-(k*descA->mb)) : descA->mb;  /* Block size in A (k dimension) */
    int ldak = BLKLDD( descA, k );    /* Leading dimension of A block */
    double zbeta = (k==0) ? beta : (double)1.;  /* Beta coefficient: use input beta for first iteration, 1.0 for others */
    int ldcn = BLKLDD( descC, n );    /* Leading dimension of C block */

    /* Debug logging for SYRK operation */
    printlog("CORE_Dsyrk(%d, %d)\n"
             "\t(uplo, trans, tempnn, tempkm, alpha, A(%d,%d)[%p], ldak, zbeta, C(%d,%d)[%p], ldcn)\n",
             n, k, k, n, A, n, n, C);

    cublasStatus_t status;
    cudaError_t err;

    /* Handle mixed precision computation based on iteration and tensor core settings */
    if((k!=descA->mt-1)){
        /* Not the last iteration - use mixed precision based on tensor_gemm setting */
        switch(params_tlr->tensor_gemm) {
            case 0 :
                /* Double precision mode - tensor core disabled */
                if(inttype!=0){
                    fprintf(stderr, "tensor core is disabled the input type should be equal 0\n");
                }else{
                    /* Get CUDA workspace and cuBLAS handle for GPU computation */
                    parsec_potrf_workspace_t *_ws_gpu = (parsec_potrf_workspace_t *)ws_gpu;
                    parsec_potrf_stream_workspace_t *stream_found = lookup_gpu_workspace(cuda_device, cuda_stream, _ws_gpu);
                    cublasHandle_t handle = stream_found->handle_cublas;
                    cublasSetStream( handle, cuda_stream->cuda_stream );

                    /* Perform SYRK using double precision cuBLAS */
                    status = cublasDsyrk( handle, CUBLAS_FILL_MODE_LOWER, CUBLAS_OP_T,
                                tempnn, tempkm,
                                &alpha, A, ldak,
                                &zbeta, C, ldcn);
                }
            break;
            case 8: 
                /* 8-bit integer mode with tensor core acceleration - AB8I_C32I_OP32I */
                if(inttype!=8){
                    fprintf(stderr, "tensor core is enabled the input type should be equal 8\n");
                }else{
                    /* Convert double precision scalars to integers for 8-bit integer computation */
                    int ialpha=(int)alpha;   /* Alpha coefficient as integer */
                    int izbeta=(int)zbeta;   /* Beta coefficient as integer */

                    /* Get CUDA workspace and cuBLAS handle for GPU computation */
                    parsec_potrf_workspace_t *_ws_gpu = (parsec_potrf_workspace_t *)ws_gpu;
                    parsec_potrf_stream_workspace_t *stream_found = lookup_gpu_workspace(cuda_device, cuda_stream, _ws_gpu);
                    cublasHandle_t handle = stream_found->handle_cublas;
                    cublasSetStream( handle, cuda_stream->cuda_stream );

                    /* Convert C from double to integer on first iteration */
                    if(k==0) double_2int_array_unary(tempnn, tempnn, C, ldcn, parsec_body.stream);

                    /* Perform SYRK using 8-bit integer input and 32-bit integer output with tensor core */
                    /* A8I_C32I_OP32I: 8-bit integer inputs, 32-bit integer output, 32-bit integer operations */
                    status = cublasGemmEx(handle, CUBLAS_OP_T, CUBLAS_OP_N,
                                   tempnn, tempnn, tempkm,
                                   &ialpha, A, CUDA_R_8I, ldak, 
                                            A, CUDA_R_8I, ldak, 
                                   &izbeta, C, CUDA_R_32I, ldcn, 
                                               CUBLAS_COMPUTE_32I, CUBLAS_GEMM_DEFAULT_TENSOR_OP); 
                    
                    /* Convert C from integer back to double on second-to-last iteration */
                    if(k==descA->mt-2) int_2double_array_unary(tempnn, tempnn, C, ldcn, parsec_body.stream);
               }
               break;
        }//switch(tensorgemm) 
     }else{
        /* Last iteration - always use double precision for final result */

        /* Get CUDA workspace and cuBLAS handle for GPU computation */
        parsec_potrf_workspace_t *_ws_gpu = (parsec_potrf_workspace_t *)ws_gpu;
        parsec_potrf_stream_workspace_t *stream_found = lookup_gpu_workspace(cuda_device, cuda_stream, _ws_gpu);
        cublasHandle_t handle = stream_found->handle_cublas;
        cublasSetStream( handle, cuda_stream->cuda_stream );

        /* Perform final SYRK using double precision cuBLAS */
        status = cublasDsyrk( handle, CUBLAS_FILL_MODE_LOWER, CUBLAS_OP_T,
                    tempnn, tempkm,
                    &alpha, A, ldak,
                    &zbeta, C, ldcn);

       // parsec_print_tile(A, descA->mb, descA->nb);

    }
}
END

BODY
{

}
END

isyrk_in_data_A0(n, k) [profile = off]
  /* Execution Space */
  n = 0..(descC->nt-1)
  k = 0..(descA->mt-1)

  /* Locality */
  : descA(k,n)

  
  READ  A    <- ((k!=descA->mt-1) && (inttype == 8 )) ? descA(k,n)               [type = FULL_I8]
             <- ((k!=descA->mt-1) && (inttype == 0 )) ? descA(k,n)               [type = FULL_DP]
             <- ((k==descA->mt-1)) ? descA(k,n)                                  [type = FULL_DP]

             -> ((k!=descA->mt-1) && (inttype == 8 )) ? A isyrk(n, k)            [type = FULL_I8]
             -> ((k!=descA->mt-1) && (inttype == 0 )) ? A isyrk(n, k)            [type = FULL_DP]
             -> (k==descA->mt-1) ? A isyrk(n, k)                                 [type = FULL_DP]


BODY
{
    /* nothing */
}
END

sgemm(n, m, k)
  /* Execution Space */
  n = 0..(descC->mt-2)
  m = (n+1)..(descC->mt-1)
  k = 0..(descA->mt-1)

  /* Locality */
  : descC(m,n)

  
  READ  A    <- ((k!=descA->mt-1) && (inttype == 8 )) ?  A sgemm_in_data_A0(m, k)           [type = FULL_I8]
             <- ((k!=descA->mt-1) && (inttype == 0 )) ?  A sgemm_in_data_A0(m, k)           [type = FULL_DP]
             <- ((k==descA->mt-1)) ?  A sgemm_in_data_A0(m, k)                               [type = FULL_DP]

 READ  B     <- ((k!=descA->mt-1) && (inttype == 8 )) ? B sgemm_in_data_A1(n, k)            [type = FULL_I8]
             <- ((k!=descA->mt-1) && (inttype == 0 )) ? B sgemm_in_data_A1(n, k)            [type = FULL_DP]
             <- ((k==descA->mt-1)) ? B sgemm_in_data_A1(n, k)                                [type = FULL_DP]

  RW    C    <- ((k>=1)&& (inttype == 8 )) ? C sgemm(n, m, k-1)                   [type = FULL_I8]
             <- ((k>=1)&& (inttype == 0 )) ? C sgemm(n, m, k-1)                   [type = FULL_DP]
             <- ((0==k)) ? descC(m,n)
             -> ((descA->mt==(k+1))) ? descC(m,n)             
             -> ((descA->mt>=(2+k)) && (inttype == 8 )) ? C sgemm(n, m, k+1)       [type = FULL_I8]
             -> ((descA->mt>=(2+k))&& (inttype == 0 )) ? C sgemm(n, m, k+1)       [type = FULL_DP]

BODY [type=CUDA]
{
    int tempmm = ((m)==(descC->mt-1)) ? (descC->m-(m*descC->mb)) : descC->mb;
    int tempnn = (n==(descC->nt-1)) ? (descC->n-(n*descC->nb)) : descC->nb;
    int tempkm = (k==(descA->mt-1)) ? (descA->m-(k*descA->mb)) : descA->mb;
    int ldak = BLKLDD( descA, k );
    double zbeta = (k==0) ? beta : ((double)1.);
    int ldcm = BLKLDD( descC, m );

      cublasStatus_t status;
      cudaError_t err;

    printlog("CORE_sDgemm(%d, %d, %d)\n"
             "\t(trans, dplasmaNoTrans, tempmm, tempnn, tempkm, zalpha, A(%d,%d)[%p], ldak, A(%d,%d)[%p], ldak, zbeta, C(%d,%d)[%p], ldcm)\n",
             n, m, k, k, m, A, k, n, B, m, n, C);
      if((k!=descA->mt-1)){

          switch(params_tlr->tensor_gemm) {
              case 0 :
                  if(inttype!=0){
                      fprintf(stderr, "tensor core is disabled the input type should be equal 0\n");
                  }else{
    /* Get handle_cublas */
    parsec_potrf_workspace_t *_ws_gpu = (parsec_potrf_workspace_t *)ws_gpu;
    parsec_potrf_stream_workspace_t *stream_found = lookup_gpu_workspace(cuda_device, cuda_stream, _ws_gpu);
    cublasHandle_t handle = stream_found->handle_cublas;
    cublasSetStream( handle, cuda_stream->cuda_stream );


                      status = cublasDgemm( handle, CUBLAS_OP_T, CUBLAS_OP_N,
                                   tempmm, tempnn, tempkm,
                                   &alpha, A, ldak,
                                   B, ldak,
                                   &zbeta, C, ldcm );
                }
              break;
              case 8:
                  if(inttype!=8){
                      fprintf(stderr, "tensor core is enabled the input type should be equal 8\n");
                  }else{
                      int ialpha=(int)alpha;
                      int izbeta=(int)zbeta;

    /* Get handle_cublas */
    parsec_potrf_workspace_t *_ws_gpu = (parsec_potrf_workspace_t *)ws_gpu;
    parsec_potrf_stream_workspace_t *stream_found = lookup_gpu_workspace(cuda_device, cuda_stream, _ws_gpu);
    cublasHandle_t handle = stream_found->handle_cublas;
    cublasSetStream( handle, cuda_stream->cuda_stream );

                      if(k==0) double_2int_array_unary(tempmm, tempnn, C, ldcm, parsec_body.stream); //convert_s2i_unary_CPU(C, tempnn, tempnn, ldcn);


                      //A8I_C32I_OP32I
                      status = cublasGemmEx(handle, CUBLAS_OP_T, CUBLAS_OP_N,
                                   tempmm, tempnn, tempkm,
                                   &ialpha, A, CUDA_R_8I, ldak,
                                            B, CUDA_R_8I, ldak,
                                   &izbeta, C, CUDA_R_32I, ldcm,
                                               CUBLAS_COMPUTE_32I, CUBLAS_GEMM_DEFAULT_TENSOR_OP);

                    if(k==descA->mt-2) int_2double_array_unary(tempmm, tempnn, C, ldcm, parsec_body.stream); //convert_i2s_unary_CPU(C, tempnn, tempnn, ldcn);

               }
              break;

           } //switch
        //parsec_print_tile(A, descA->mb, descA->nb);
     }else{
    /* Get handle_cublas */
    parsec_potrf_workspace_t *_ws_gpu = (parsec_potrf_workspace_t *)ws_gpu;
    parsec_potrf_stream_workspace_t *stream_found = lookup_gpu_workspace(cuda_device, cuda_stream, _ws_gpu);
    cublasHandle_t handle = stream_found->handle_cublas;
    cublasSetStream( handle, cuda_stream->cuda_stream );


           status = cublasDgemm( handle, CUBLAS_OP_T, CUBLAS_OP_N,
                        tempmm, tempnn, tempkm,
                        &alpha, A, ldak,
                        B, ldak,
                        &zbeta,  C, ldcm );

    }
}
END

BODY
{

}
END

sgemm_in_data_A1(n, k) [profile = off]
  /* Execution Space */
  n = 0..(descC->mt-2)
  k = 0..(descA->mt-1)

  /* Locality */
  : descA(k,n)

  
  READ  B    <- ((k!=descA->mt-1) && (inttype == 8 )) ?  descA(k,n)                                   [type = FULL_I8]
             <- ((k!=descA->mt-1) && (inttype == 0 )) ?  descA(k,n)                                   [type = FULL_DP]
             <- ((k==descA->mt-1)) ?  descA(k,n)                                                      [type = FULL_DP]

             -> ((k!=descA->mt-1) && (inttype == 8)) ?  B sgemm(n, (n+1)..(descC->mt-1), k)           [type = FULL_I8]
             -> ((k!=descA->mt-1) && (inttype == 0)) ?  B sgemm(n, (n+1)..(descC->mt-1), k)           [type = FULL_DP]
             -> ((k==descA->mt-1)) ?  B sgemm(n, (n+1)..(descC->mt-1), k)                             [type = FULL_DP]


BODY
{
    /* nothing */
}
END

sgemm_in_data_A0(m, k) [profile = off]
  /* Execution Space */
  m = 1..(descC->mt-1) /* tight bound is (n+1)..(descC->mt-1) */
  k = 0..(descA->mt-1)

  /* Locality */
  : descA(k,m)

   
  READ  A    <- ((k!=descA->mt-1) && (inttype == 8)) ?  descA(k,m)              [type = FULL_I8]
             <- ((k!=descA->mt-1) && (inttype == 0)) ?  descA(k,m)                                    [type = FULL_DP]
             <- ((k==descA->mt-1)) ?  descA(k,m)                                                      [type = FULL_DP]

             -> ((k!=descA->mt-1) && (inttype == 8)) ? A sgemm(0..(descC->mt-2), m, k)                [type = FULL_I8]
             -> ((k!=descA->mt-1) && (inttype == 0)) ? A sgemm(0..(descC->mt-2), m, k)                [type = FULL_DP]
             -> ((k==descA->mt-1)) ? A sgemm(0..(descC->mt-2), m, k)                                  [type = FULL_DP]

BODY
{
    /* nothing */
}
END
