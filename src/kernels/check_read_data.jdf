extern "C" %{
/**
 * @copyright (c) 2023-2025     Saint Louis University (SLU)
 * @copyright (c) 2023-2025     Massachusetts Institute of Technology (MIT)
 * @copyright (c) 2023-2025     Nvidia Corporation
 * @copyright (c) 2018-2025     King Abdullah University of Science and Technology (KAUST)
 * @copyright (c) 2018-2023     The University of Tennessee and The University of Tennessee Research Foundation
 *                              All rights reserved.
 **/

#include "hicma_parsec.h"

%}

/* Global variables for data flow verification
 * This kernel tests the correctness of PaRSEC's data flow mechanisms
 * by implementing a simple producer-consumer pattern with data dependencies.
 */
descA           [ type = "parsec_tiled_matrix_t*" ]  // Matrix descriptor for test data
params_tlr      [ type = "hicma_parsec_params_t *" ] // Runtime parameters (unused in this test)

/**************************************************
 * Task 1: Initialize test data
 * Sets up initial value and triggers the data flow chain
 **************************************************/
Init(m, n)

// Execution space: single tile at position (0,0)
m = 0 .. 0
n = 0 .. 0

// Parallel partitioning: operates on the single test tile
:descA(m, n)

// Parameters: read-write access to initialize the test data
RW D <- descA(m, n)
     -> descA(m, n) 

// Control flow: triggers the Read task after initialization
CTL ctl -> ctl Read(m, n)

BODY
{   
    // Initialize test data to 0 and log the initial state
    ((int *)D)[0] = 0;
    fprintf(stderr, "Initial value %d\n", ((int *)D)[0]);
}
END

/**************************************************
 * Task 2: Read and modify data
 * Demonstrates data dependency by reading from Init and producing for Task
 **************************************************/
Read(m, n)

// Execution space: single tile at position (0,0)
m = 0 .. 0 
n = 0 .. 0 

// Parallel partitioning: operates on the same test tile
:descA(m, n)

// Parameters: read from Init task, produce data for Task
READ D <- descA(m, n)               
       -> D Task(m, n) 

// Control flow: depends on Init task completion
CTL ctl <- ctl Init(m, n)

BODY
{
    // Modify the data to demonstrate successful read operation
    ((int *)D)[0] = 1;
}
END

/**************************************************
 * Task 3: Process data
 * Consumes data from Read task and triggers finalization
 **************************************************/
Task(m, n)

// Execution space: single tile at position (0,0)
m = 0 .. 0
n = 0 .. 0

// Parallel partitioning: operates on the same test tile
:descA(m, n)

// Parameters: read data produced by Read task
READ D <- D Read(m, n)

// Control flow: triggers finalization after processing
CTL ctl -> ctl Fini(m, n)

BODY
{   
    // This task serves as a data consumer - no processing needed for the test
    // The mere fact that this task executes confirms the data flow is working
}
END

/**************************************************
 * Task 4: Finalize and verify
 * Reads final data state and logs the result
 **************************************************/
Fini(m, n)

// Execution space: single tile at position (0,0)
m = 0 .. 0
n = 0 .. 0

// Parallel partitioning: operates on the same test tile
:descA(m, n)

// Parameters: read final state of the data
READ D <- descA(m, n)

// Control flow: depends on Task completion
CTL ctl <- ctl Task(m, n)

BODY
{   
    // Log the final value to verify the complete data flow chain
    fprintf(stderr, "Final value %d\n", ((int *)D)[0]);
}
END




extern "C" %{

/**
 * Create a new taskpool for testing PaRSEC data flow mechanisms
 * 
 * This function creates and initializes a PaRSEC taskpool that implements
 * a simple producer-consumer pattern to verify that data dependencies
 * and read operations are handled correctly by the PaRSEC runtime.
 * 
 * The test uses a single tile and implements a chain: Init -> Read -> Task -> Fini
 * to verify proper data flow and dependency management.
 *
 * @param [in] parsec:     PaRSEC runtime context (unused but kept for interface consistency)
 * @param [in] A:          tiled matrix descriptor containing the test data tile
 * @param [in] params_tlr: runtime parameters (unused in this test)
 * @return the parsec taskpool object to schedule, or NULL on failure
 */
parsec_taskpool_t*
hicma_parsec_check_read_data_New( parsec_context_t *parsec,
        parsec_tiled_matrix_t *A,
        hicma_parsec_params_t *params_tlr)
{
    parsec_check_read_data_taskpool_t *check_read_data = parsec_check_read_data_new(A, params_tlr);
    return (parsec_taskpool_t*)check_read_data;
}

/**
 * Destructor for the check read data taskpool
 * 
 * Properly cleans up and deallocates the taskpool and all associated resources.
 * This function should be called after the taskpool execution is complete.
 *
 * @param [inout] taskpool: the parsec taskpool object to destroy and deallocate
 */
void hicma_parsec_check_read_data_Destruct(parsec_taskpool_t *taskpool)
{
    parsec_check_read_data_taskpool_t *check_read_data_taskpool = (parsec_check_read_data_taskpool_t *)taskpool;
    parsec_taskpool_free(taskpool);
}

/**
 * High-level interface to test PaRSEC data flow mechanisms
 * 
 * This function provides a complete workflow for testing the correctness
 * of PaRSEC's data flow and dependency management. It creates a taskpool
 * with a simple producer-consumer pattern, schedules execution, waits for
 * completion, and properly cleans up resources.
 * 
 * The test verifies that:
 * - Data dependencies are properly enforced
 * - Read operations work correctly
 * - Task scheduling respects data flow constraints
 * - The complete execution chain works as expected
 * 
 * Expected output: "Initial value 0" followed by "Final value 1"
 *
 * @param [in] parsec:     PaRSEC runtime context for task scheduling and execution
 * @param [in] A:          tiled matrix descriptor containing the test data tile
 * @param [in] params_tlr: runtime parameters (unused in this test)
 * @return 0 on success, non-zero on failure
 */
int hicma_parsec_check_read_data( parsec_context_t *parsec,
        parsec_tiled_matrix_t *A,
        hicma_parsec_params_t *params_tlr)
{
    parsec_taskpool_t *parsec_check_read_data = NULL;
    
    // Create the taskpool for data flow testing
    parsec_check_read_data = hicma_parsec_check_read_data_New(parsec, A, params_tlr); 
    
    // Execute the test if taskpool creation was successful
    parsec_context_add_taskpool(parsec, parsec_check_read_data);
    parsec_context_start(parsec);
    parsec_context_wait(parsec);
    hicma_parsec_check_read_data_Destruct(parsec_check_read_data);
   
    return 0; 
}

%}
