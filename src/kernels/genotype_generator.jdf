extern "C" %{
/**
 * @copyright (c) 2023-2025     Saint Louis University (SLU)
 * @copyright (c) 2023-2025     Massachusetts Institute of Technology (MIT)
 * @copyright (c) 2023-2025     Nvidia Corporation
 * @copyright (c) 2018-2025     King Abdullah University of Science and Technology (KAUST)
 * @copyright (c) 2018-2023     The University of Tennessee and The University of Tennessee Research Foundation
 *                              All rights reserved.
 **/
#include "hicma_parsec.h"
#include <time.h>

/**
 * @brief Global seed for reproducible random number generation
 * 
 * This constant seed ensures consistent random data generation across runs,
 * which is important for reproducible genotype data generation in scientific
 * applications. The seed value is chosen to provide good randomness properties.
 */
#define globalseed 1619477613

/**
 * @brief Generate identity matrix data with mixed random values
 * @param [out] A: Output matrix data (float array)
 * @param [in] mb: Number of rows in the tile
 * @param [in] nb: Number of columns in the tile
 * @param [in] lda: Leading dimension of the matrix
 * @param [in] m: Current tile row index
 * @param [in] mt: Total number of tile rows
 * 
 * This function generates mixed data types for identity matrix simulation:
 * - For non-last tiles: generates discrete integer values 0, 1, or 2 (genotype-like)
 * - For last tile: generates continuous float values between 0 and 1 (phenotype-like)
 * 
 * The mixed approach simulates real genetic data where genotypes are discrete
 * and phenotypes are continuous.
 */
static void generate_id(float *A, int mb, int nb, int lda, int m, int mt){
    int i,j;
    int lower = 0, upper = 2;  // Range for discrete genotype values (0, 1, 2)
    unsigned int seed = globalseed;
    rand_r(&seed);  // Initialize random number generator with global seed

    // Fill the matrix tile with data based on tile position
    for(i=0;i<mb;i++){
        for(j=0;j<nb;j++){
            if(m!=mt){
                // Generate discrete integer values 0, 1, or 2 for non-last tiles
                // This simulates genotype data (AA=0, Aa=1, aa=2)
                A[j*lda+i]=(float)(rand_r(&seed) % (upper - lower + 1)) + lower;
            }else{
                // Generate continuous float values between 0 and 1 for last tile
                // This simulates phenotype data (continuous traits)
                A[j*lda+i]=(float)((float)rand_r(&seed) / RAND_MAX);
            }
        }
    }
}

/**
 * @brief Generate integer data for genotype matrices
 * @param [out] A: Output matrix data (int8_t array)
 * @param [in] mb: Number of rows in the tile
 * @param [in] nb: Number of columns in the tile
 * @param [in] lda: Leading dimension of the matrix
 * @param [in] m: Current tile row index
 * @param [in] mt: Total number of tile rows
 * 
 * This function generates discrete integer genotype data using int8_t precision
 * for memory efficiency. The values 0, 1, 2 represent different genotype states:
 * - 0: Homozygous reference (AA)
 * - 1: Heterozygous (Aa) 
 * - 2: Homozygous alternative (aa)
 * 
 * Using int8_t reduces memory usage compared to float while maintaining
 * the discrete nature of genotype data.
 */
static void generate_i(int8_t *A, int mb, int nb, int lda, int m, int mt){
    int i,j;
    int lower = 0, upper = 2;  // Range for discrete genotype values (0, 1, 2)
    unsigned int seed = globalseed;
    rand_r(&seed);  // Initialize random number generator with global seed

    // Fill the matrix tile with integer genotype data
    for(i=0;i<mb;i++)
        for(j=0;j<nb;j++)
            // Generate discrete integer values 0, 1, or 2 representing genotype states
            // This efficiently represents the three possible genotype combinations
            A[j*lda+i]=(int8_t)(rand_r(&seed) % (upper - lower + 1)) + lower;
}

/**
 * @brief Generate float data for phenotype matrices
 * @param [out] A: Output matrix data (float array)
 * @param [in] mb: Number of rows in the tile
 * @param [in] nb: Number of columns in the tile
 * @param [in] lda: Leading dimension of the matrix
 * @param [in] m: Current tile row index
 * @param [in] mt: Total number of tile rows
 * 
 * This function generates continuous float phenotype data with values between 0 and 1.
 * Unlike discrete genotype data, phenotype data represents continuous traits such as
 * height, weight, or other measurable characteristics that can take any value
 * within a range.
 * 
 * The uniform distribution between 0 and 1 simulates normalized phenotype values.
 */
static void generate_f(float *A, int mb, int nb, int lda, int m, int mt){
    int i,j;
    int lower = 0, upper = 2;  // Unused in this function (kept for consistency with other generators)
    unsigned int seed = globalseed;
    rand_r(&seed);  // Initialize random number generator with global seed
    
    // Fill the matrix tile with continuous float phenotype data
    for(i=0;i<mb;i++)
        for(j=0;j<nb;j++){
            // Generate random float values between 0 and 1
            // This creates continuous phenotype-like values representing normalized traits
            A[j*lda+i]=(float)((float)rand_r(&seed) / RAND_MAX);
        }
}


%}

/**
 * @brief Input parameters for the genotype generator task
 * 
 * These parameters define the configuration for generating genotype/phenotype data
 * in matrix tiles with different precision and allocation strategies.
 */
descA           [ type = "parsec_tiled_matrix_t*" ]  // Matrix descriptor for the output matrix
params_tlr      [ type = "hicma_parsec_params_t *" ] // TLR parameters containing GPU and allocation settings
genetype        [ type = "int" ]                     // Type of data to generate (0=identity matrix, 1=genotype data)

/**
 * @brief PaRSEC task for generating genotype data in matrix tiles
 * 
 * This task generates random data for genotype matrices with different data types
 * and allocation strategies based on build configuration and GPU availability.
 */
genotype_generator(m, n)

// Iterate over all matrix tiles
m = 0 .. descA->mt-1  // Row index from 0 to number of tiles in rows - 1
n = 0 .. descA->nt-1  // Column index from 0 to number of tiles in columns - 1

: descA(m, n)  // Depend on the matrix tile at position (m,n)

// Read-write access to matrix tile A
// Input: read from matrix tile at position (m,n)
// Output: write generated data to the same matrix tile
RW A <- descA(m, n)              
     -> descA(m, n)        

// Remote data types for different precision levels
READ A1 <- NULL                       [ type_remote = FULL_SP ]  // Single precision remote data (float)
READ A2 <- NULL                       [ type_remote = FULL_I8 ]  // 8-bit integer remote data (int8_t)

BODY
{
    // Calculate actual tile dimensions (handle edge tiles)
    int tempmm, tempnn, ldam, ldbm;
    int i, j;
    
    // Actual number of rows in this tile (handle last tile in column)
    // For the last tile in a column, use remaining rows instead of full tile size
    tempmm = ((m)==((descA->mt)-1)) ? ((descA->m)-(m*(descA->mb))) : (descA->mb);
    
    // Actual number of columns in this tile (handle last tile in row)
    // For the last tile in a row, use remaining columns instead of full tile size
    tempnn = ((n)==((descA->nt)-1)) ? ((descA->n)-(n*(descA->nb))) : (descA->nb);
    
    // Leading dimension of the tile (stride between rows)
    ldam = BLKLDD( descA, m );

    // Memory allocation and data generation based on build configuration
#if GENOMICS_ALLOCATE_SP
    // Allocate single precision data structure
    this_task->data._f_A.data_out = parsec_data_copy_new(data_of_descA(m, n), 0, PARSEC_genotype_generator_FULL_SP_ADT->opaque_dtt, PARSEC_DATA_FLAG_PARSEC_MANAGED);
    this_task->data._f_A.data_out->original->nb_elts = descA->mb * descA->nb * sizeof(float);

    // Allocate device memory based on GPU availability
    if( params_tlr->gpus > 0 ) {
#if defined(PARSEC_HAVE_DEV_CUDA_SUPPORT)
        // CUDA pinned host memory allocation for GPU acceleration
        cudaMallocHost((void**)&this_task->data._f_A.data_out->device_private, descA->mb * descA->nb * sizeof(float));
#endif

#if defined(PARSEC_HAVE_DEV_HIP_SUPPORT)
        // HIP pinned host memory allocation for GPU acceleration
        hipHostMalloc((void**)&this_task->data._f_A.data_out->device_private, descA->mb * descA->nb * sizeof(float), hipHostMallocDefault);
#endif
    }
    else {
        // CPU memory allocation for CPU-only execution
        this_task->data._f_A.data_out->device_private = calloc(descA->mb * descA->nb, sizeof(float));
    }

    // Generate data based on genotype type
    if (genetype) {
        // Generate float data for genotype matrices (continuous values 0-1)
        generate_f(this_task->data._f_A.data_out->device_private, tempmm, tempnn, ldam, m, descA->mt-1);
    } else {
        // Generate identity matrix data (mixed discrete/continuous values)
        generate_id(this_task->data._f_A.data_out->device_private, tempmm, tempnn, ldam, m, descA->mt-1);
    }

#else
    // Alternative allocation strategy: mixed precision based on tile position
    if( params_tlr->gpus > 0 ) {
#if defined(PARSEC_HAVE_DEV_CUDA_SUPPORT)
        // CUDA memory allocation with mixed precision strategy
        if( m == descA->mt-1 ) {
            // Last row: use single precision or int8 based on configuration
        #if GENOMICS_ALLOCATE_INT
            // Allocate int8 data for last row (memory-efficient for genotype data)
            this_task->data._f_A.data_out = parsec_data_copy_new(data_of_descA(m, n), 0, PARSEC_genotype_generator_FULL_I8_ADT->opaque_dtt, PARSEC_DATA_FLAG_PARSEC_MANAGED);
            cudaMallocHost((void**)&this_task->data._f_A.data_out->device_private, descA->mb * descA->nb * sizeof(int8_t));
            this_task->data._f_A.data_out->original->nb_elts = descA->mb * descA->nb * sizeof(int8_t);
        #else
            // Allocate single precision data for last row (higher precision for phenotype data)
            this_task->data._f_A.data_out = parsec_data_copy_new(data_of_descA(m, n), 0, PARSEC_genotype_generator_FULL_SP_ADT->opaque_dtt, PARSEC_DATA_FLAG_PARSEC_MANAGED);
            cudaMallocHost((void**)&this_task->data._f_A.data_out->device_private, descA->mb * descA->nb * sizeof(float));
            this_task->data._f_A.data_out->original->nb_elts = descA->mb * descA->nb * sizeof(float);
        #endif
        } else {
            // Non-last rows: use int8 data (memory-efficient for genotype data)
            this_task->data._f_A.data_out = parsec_data_copy_new(data_of_descA(m, n), 0, PARSEC_genotype_generator_FULL_I8_ADT->opaque_dtt, PARSEC_DATA_FLAG_PARSEC_MANAGED);
            cudaMallocHost((void**)&this_task->data._f_A.data_out->device_private, descA->mb * descA->nb * sizeof(int8_t));
            this_task->data._f_A.data_out->original->nb_elts = descA->mb * descA->nb * sizeof(int8_t);
        }
#endif

#if defined(PARSEC_HAVE_DEV_HIP_SUPPORT)
        // HIP memory allocation with mixed precision strategy
        if( m == descA->mt-1 ) {
            // Last row: use single precision data (higher precision for phenotype data)
            this_task->data._f_A.data_out = parsec_data_copy_new(data_of_descA(m, n), 0, PARSEC_genotype_generator_FULL_SP_ADT->opaque_dtt, PARSEC_DATA_FLAG_PARSEC_MANAGED);
            hipHostMalloc((void**)&this_task->data._f_A.data_out->device_private, descA->mb * descA->nb * sizeof(float), hipHostMallocDefault);
            this_task->data._f_A.data_out->original->nb_elts = descA->mb * descA->nb * sizeof(float);
        } else {
            // Non-last rows: use int8 data (memory-efficient for genotype data)
            this_task->data._f_A.data_out = parsec_data_copy_new(data_of_descA(m, n), 0, PARSEC_genotype_generator_FULL_I8_ADT->opaque_dtt, PARSEC_DATA_FLAG_PARSEC_MANAGED);
            hipHostMalloc((void**)&this_task->data._f_A.data_out->device_private, descA->mb * descA->nb * sizeof(int8_t), hipHostMallocDefault);
            this_task->data._f_A.data_out->original->nb_elts = descA->mb * descA->nb * sizeof(int8_t);
        }
#endif
    }
    else {
        // CPU memory allocation with mixed precision strategy
        if( m == descA->mt-1 ) {
            // Last row: use int8 or single precision based on configuration
            #if GENOMICS_ALLOCATE_INT
            // Allocate int8 data for last row (memory-efficient for genotype data)
            this_task->data._f_A.data_out = parsec_data_copy_new(data_of_descA(m, n), 0, PARSEC_genotype_generator_FULL_I8_ADT->opaque_dtt, PARSEC_DATA_FLAG_PARSEC_MANAGED);
            this_task->data._f_A.data_out->device_private = calloc(descA->mb * descA->nb, sizeof(int8_t));
            this_task->data._f_A.data_out->original->nb_elts = descA->mb * descA->nb * sizeof(int8_t);
            #else
            // Allocate single precision data for last row (higher precision for phenotype data)
            this_task->data._f_A.data_out = parsec_data_copy_new(data_of_descA(m, n), 0, PARSEC_genotype_generator_FULL_SP_ADT->opaque_dtt, PARSEC_DATA_FLAG_PARSEC_MANAGED);
            this_task->data._f_A.data_out->device_private = calloc(descA->mb * descA->nb, sizeof(float));
            this_task->data._f_A.data_out->original->nb_elts = descA->mb * descA->nb * sizeof(float);
            #endif
        } else {
            // Non-last rows: use int8 data (memory-efficient for genotype data)
            this_task->data._f_A.data_out = parsec_data_copy_new(data_of_descA(m, n), 0, PARSEC_genotype_generator_FULL_I8_ADT->opaque_dtt, PARSEC_DATA_FLAG_PARSEC_MANAGED);
            this_task->data._f_A.data_out->device_private = calloc(descA->mb * descA->nb, sizeof(int8_t));
            this_task->data._f_A.data_out->original->nb_elts = descA->mb * descA->nb * sizeof(int8_t);
        }
    }

    // Generate data based on genotype type and tile position
    if (genetype) {
        // Generate genotype data
        if( m == descA->mt-1 ) {
            // Last row: generate data based on allocation type
            #if GENOMICS_ALLOCATE_INT
                // Generate integer genotype data for last row (discrete values 0,1,2)
                generate_i(this_task->data._f_A.data_out->device_private, tempmm, tempnn, ldam, m, descA->mt-1);
            #else
                // Generate float genotype data for last row (continuous values 0-1)
                generate_f(this_task->data._f_A.data_out->device_private, tempmm, tempnn, ldam, m, descA->mt-1);
            #endif
        } else {
            // Non-last rows: generate integer genotype data (discrete values 0,1,2)
            generate_i(this_task->data._f_A.data_out->device_private, tempmm, tempnn, ldam, m, descA->mt-1);
        }
    } else {
        // Generate identity matrix data (mixed discrete/continuous values)
        generate_id(this_task->data._f_A.data_out->device_private, tempmm, tempnn, ldam, m, descA->mt-1);
    }

#endif

}
END

extern "C" %{

    /**
     * @brief Create a new taskpool for genotype data generation
     * @param [in] A: the tiled matrix data, already distributed and allocated
     * @param [in] params: TLR parameters containing GPU and allocation settings
     * @param [in] genetype: type of data to generate (0=identity, 1=genotype)
     * @return the parsec taskpool object to schedule
     */
    parsec_taskpool_t*
        parsec_genotype_generator_New(parsec_tiled_matrix_t *A, hicma_parsec_params_t *params, int genetype) 
        {
            parsec_taskpool_t* band_genotype_generator_taskpool;
            parsec_genotype_generator_taskpool_t* taskpool = NULL;

            // Create the taskpool for genotype generation
            taskpool = parsec_genotype_generator_new(A, params, genetype);
            band_genotype_generator_taskpool = (parsec_taskpool_t*)taskpool;

            // Add single precision arena for float data (phenotype data)
            // This arena manages memory allocation for continuous phenotype values
            parsec_add2arena(&taskpool->arenas_datatypes[PARSEC_genotype_generator_FULL_SP_ADT_IDX],
                    parsec_datatype_float_t, PARSEC_MATRIX_FULL,
                    1, A->mb, A->nb, A->mb,
                    PARSEC_ARENA_ALIGNMENT_SSE, -1 );

            // Add int8 arena for integer genotype data (discrete genotype values)
            // This arena manages memory allocation for discrete genotype values (0,1,2)
            parsec_add2arena(&taskpool->arenas_datatypes[PARSEC_genotype_generator_FULL_I8_ADT_IDX],
                    parsec_datatype_int8_t, PARSEC_MATRIX_FULL,
                    1, A->mb, A->nb, A->mb,
                    PARSEC_ARENA_ALIGNMENT_SSE, -1 );

            return band_genotype_generator_taskpool;
        }

    /**
     * @brief Destroy the genotype generator taskpool
     * @param [inout] taskpool: the parsec taskpool object to destroy
     */
void parsec_genotype_generator_Destruct(parsec_taskpool_t *taskpool)
{
    parsec_genotype_generator_taskpool_t *genotype_generator_taskpool = (parsec_genotype_generator_taskpool_t *)taskpool;
    
    // Remove single precision arena (float data)
    parsec_del2arena(&genotype_generator_taskpool->arenas_datatypes[PARSEC_genotype_generator_FULL_SP_ADT_IDX]);
    
    // Remove int8 arena (integer genotype data)
    parsec_del2arena(&genotype_generator_taskpool->arenas_datatypes[PARSEC_genotype_generator_FULL_I8_ADT_IDX]);
    
    // Free the taskpool memory
    parsec_taskpool_free(taskpool);
}

/**
 * @brief Main function to generate genotype data for all matrix tiles
 * @param [in] parsec: parsec context for task scheduling
 * @param [in] A: tiled matrix descriptor
 * @param [in] params: TLR parameters containing GPU and allocation settings
 * @param [in] genetype: type of data to generate (0=identity, 1=genotype)
 * @return 0 on success
 */
int parsec_genotype_generator(parsec_context_t *parsec,
        parsec_tiled_matrix_t *A,
        hicma_parsec_params_t *params,
        int genetype) 
{
    parsec_taskpool_t *parsec_genotype_generator = NULL;

    // Create and schedule the genotype generation taskpool
    parsec_genotype_generator = parsec_genotype_generator_New(A, params, genetype);

    if( parsec_genotype_generator != NULL ){
        // Add the taskpool to the PaRSEC context for execution
        parsec_context_add_taskpool(parsec, parsec_genotype_generator);
        
        // Start the execution of tasks
        parsec_context_start(parsec);
        
        // Wait for all tasks to complete
        parsec_context_wait(parsec);
        
        // Clean up the taskpool
        parsec_genotype_generator_Destruct(parsec_genotype_generator);
    }

    return 0;
}

%}
