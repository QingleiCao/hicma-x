extern "C" %{
/**
 * @copyright (c) 2023-2025     Saint Louis University (SLU)
 * @copyright (c) 2023-2025     Massachusetts Institute of Technology (MIT)
 * @copyright (c) 2023-2025     Nvidia Corporation
 * @copyright (c) 2018-2025     King Abdullah University of Science and Technology (KAUST)
 * @copyright (c) 2018-2023     The University of Tennessee and The University of Tennessee Research Foundation
 *                              All rights reserved.
 **/
#include "hicma_parsec.h"

/* Made decisions */
extern int *decisions;

%}

// Matrix descriptor for the input/output matrix
descA         [ type = "parsec_tiled_matrix_t*" ]
// Integer type specification: 8, 16, or 32 bits
intype        [type = "int"]

// Task definition for converting single precision to integer
Convert_s2i(m, n)

// Iterate over matrix tiles (excluding last row to avoid diagonal)
m = 0 .. descA->lmt-2
n = 0 .. descA->lnt-1

: descA(m, n)                     

// Read-write access to matrix tile A
RW A <- descA(m, n)    
     -> descA(m, n)  

BODY
{
    // Local variables for tile dimensions and leading dimension
    int tempmm, tempnn, ldam, ldbm;
    
    // Calculate actual tile dimensions (handle edge tiles that may be smaller)
    tempmm = ((m)==((descA->mt)-1)) ? ((descA->m)-(m*(descA->mb))) : (descA->mb);
    tempnn = ((n)==((descA->nt)-1)) ? ((descA->n)-(n*(descA->nb))) : (descA->nb);
    ldam = BLKLDD( descA, m );
    
    // Convert single precision to integer based on specified bit width
    if( intype == 8 ){
        // Convert to 8-bit integer (int8_t)
        convert_s2i8_unary_CPU(A, tempmm, tempnn, ldam); 
        this_task->data._f_A.data_out->original->nb_elts = descA->mb * descA->nb * sizeof(int8_t);
    }else if( intype == 16 ){
        // Convert to 16-bit integer (int16_t)
        convert_s2i16_unary_CPU(A, tempmm, tempnn, ldam);
        this_task->data._f_A.data_out->original->nb_elts = descA->mb * descA->nb * sizeof(int16_t);
    }else if( intype == 32 ){
        // Convert to 32-bit integer (int)
        convert_s2i_unary_CPU(A, tempmm, tempnn, ldam);
        this_task->data._f_A.data_out->original->nb_elts = descA->mb * descA->nb * sizeof(int);
   }
}
END

extern "C" %{

/**
 * Create a new PaRSEC taskpool for single-to-integer conversion
 * @param [in] A:    the tiled matrix data, already distributed and allocated
 * @param [in] intype: integer type specification (8, 16, or 32 bits)
 * @return the parsec taskpool object to schedule
 */
parsec_taskpool_t*
parsec_convert_s2i_New(parsec_tiled_matrix_t *A, int intype) 
{
    parsec_taskpool_t* convert_s2i_taskpool;
    parsec_convert_s2i_taskpool_t* taskpool = NULL;

    // Create the taskpool instance
    taskpool = parsec_convert_s2i_new(A, intype);
    convert_s2i_taskpool = (parsec_taskpool_t*)taskpool;

    // Add double precision datatype arena for matrix operations
    parsec_add2arena(&taskpool->arenas_datatypes[PARSEC_convert_s2i_DEFAULT_ADT_IDX],
                            parsec_datatype_double_t, PARSEC_MATRIX_FULL,
                            1, A->mb, A->nb, A->mb,
                            PARSEC_ARENA_ALIGNMENT_SSE, -1 );

    return convert_s2i_taskpool;
}

/**
 * Destroy the PaRSEC taskpool and free associated resources
 * @param [inout] taskpool: the parsec taskpool object to destroy
 */
void parsec_convert_s2i_Destruct(parsec_taskpool_t *taskpool)
{
    parsec_convert_s2i_taskpool_t *convert_s2i_taskpool = (parsec_convert_s2i_taskpool_t *)taskpool;
    
    // Remove the datatype arena
    parsec_del2arena(&convert_s2i_taskpool->arenas_datatypes[PARSEC_convert_s2i_DEFAULT_ADT_IDX]);
    
    // Free the taskpool memory
    parsec_taskpool_free(taskpool);
}

/**
 * Execute single-to-integer conversion on the entire matrix
 * 
 * @param [in] parsec: the parsec context for task scheduling
 * @param [inout] A: the tiled matrix data, already distributed and allocated
 * @param [in] intype: integer type specification (8, 16, or 32 bits)
 * @return 0 on success
 */
int parsec_convert_s2i(parsec_context_t *parsec,
                         parsec_tiled_matrix_t *A, int intype) 
{
    parsec_taskpool_t *parsec_convert_s2i = NULL;

    // Create the conversion taskpool
    parsec_convert_s2i = parsec_convert_s2i_New( A, intype);

    if( parsec_convert_s2i != NULL ){
        // Schedule and execute the conversion tasks
        parsec_context_add_taskpool(parsec, parsec_convert_s2i);
        parsec_context_start(parsec);
        parsec_context_wait(parsec);
        
        // Clean up resources
        parsec_convert_s2i_Destruct(parsec_convert_s2i);
    }

    return 0;
}

%}
