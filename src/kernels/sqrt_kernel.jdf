extern "C" %{
/**
 * @copyright (c) 2023-2025     Saint Louis University (SLU)
 * @copyright (c) 2023-2025     Massachusetts Institute of Technology (MIT)
 * @copyright (c) 2023-2025     Nvidia Corporation
 * @copyright (c) 2018-2025     King Abdullah University of Science and Technology (KAUST)
 * @copyright (c) 2018-2023     The University of Tennessee and The University of Tennessee Research Foundation
 *                              All rights reserved.
 **/

#include "hicma_parsec.h"

/**
 * @file sqrt_kernel.jdf
 * @brief Square root kernel with Gaussian and exponential transformations
 * 
 * This kernel applies element-wise transformations to matrix tiles, including
 * Gaussian and exponential kernel functions. It also supports adding values
 * to diagonal elements.
 */

/**
 * @brief Apply Gaussian kernel transformation
 * 
 * Applies Gaussian kernel: exp(-rad * x^2) to each element of the matrix tile.
 * 
 * @param nb Block size (number of elements per dimension)
 * @param lda Leading dimension of matrix A
 * @param A Matrix data (modified in-place)
 * @param rad Radius parameter for Gaussian kernel
 */
void elementwise_sqrt_gaussian(int nb, int lda, double* A, double rad){
    double value;
    for( int i =0; i<nb; i++){
        for(int j =0; j <nb;j++){
            value=A[i+j*lda] * A[i+j*lda];  /* Square the element */
            A[i+j*lda] = exp(-rad*value);   /* Apply Gaussian kernel */
        }
    }
}

/**
 * @brief Apply exponential kernel transformation
 * 
 * Applies exponential kernel: exp(-rad * x) to each element of the matrix tile.
 * 
 * @param nb Block size (number of elements per dimension)
 * @param lda Leading dimension of matrix A
 * @param A Matrix data (modified in-place)
 * @param rad Radius parameter for exponential kernel
 */
void elementwise_sqrt_expon(int nb, int lda, double* A, double  rad){
    double value;
    for( int i =0; i<nb; i++){
        for(int j =0; j <nb;j++){
            value=A[i+j*lda];               /* Get element value */
            A[i+j*lda] = exp(-rad*value);   /* Apply exponential kernel */
        }
    }
}

/**
 * @brief Add value to diagonal elements
 * 
 * Adds a specified value to all diagonal elements of the matrix tile.
 * 
 * @param nb Block size (number of elements per dimension)
 * @param lda Leading dimension of matrix A
 * @param A Matrix data (modified in-place)
 * @param add_diag Value to add to diagonal elements
 */
void add_diag_tile(int nb, int lda, double* A, double  add_diag){
    for( int i =0; i<nb; i++){
        for(int j =0; j <nb;j++){
            if(i==j)  /* Only modify diagonal elements */
                A[i+i*lda] += add_diag;
        }
    }
}

%}

/* Input/Output matrix descriptors and parameters */
descA          [ type = "parsec_tiled_matrix_t *" ]  /* Input/output matrix descriptor */
rad            [ type = "double" ]                   /* Radius parameter for kernel functions */
add_diag       [ type = "double" ]                   /* Value to add to diagonal elements */
kernel         [ type = "int" ]                      /* Kernel type selector (0=Gaussian, 1=Exponential) */

/**
 * @brief Apply kernel transformation to matrix tiles
 * 
 * This task applies element-wise kernel transformations to matrix tiles.
 * It supports both Gaussian and exponential kernel functions, and can
 * optionally add values to diagonal elements.
 */
sqrt(m, n)

// Execution space: process upper triangular matrix tiles
m = 0 .. descA->lmt-1
n = 0 .. m

: descA(m, n)

RW A <- descA(m, n)
     ->descA(m, n) 

BODY
{
    /* Calculate actual tile dimensions (handle edge cases) */
    int tempmm, tempnn, ldam, ldbm;
    tempmm = ((m)==((descA->mt)-1)) ? ((descA->m)-(m*(descA->mb))) : (descA->mb);
    tempnn = ((n)==((descA->nt)-1)) ? ((descA->n)-(n*(descA->nb))) : (descA->nb);
    ldam = BLKLDD( descA, m );
    
    /* Apply kernel transformation based on kernel type */
    switch(kernel){
        case 0:  elementwise_sqrt_gaussian(tempmm, ldam, A, rad);
            break;
        case 1: elementwise_sqrt_expon(tempmm, ldam, A, rad);
            break;
        default: elementwise_sqrt_gaussian(tempmm, ldam, A, rad);
            break;
    }   
    
    /* Add value to diagonal elements for diagonal tiles */
    if(m==n)
        add_diag_tile(tempmm, ldam, A, add_diag);
}
END


extern "C" %{

/**
 * @brief Create new square root kernel taskpool
 * 
 * @param dcA Input/output matrix descriptor
 * @param rad Radius parameter for kernel functions
 * @param add_diag Value to add to diagonal elements
 * @param kernel Kernel type selector (0=Gaussian, 1=Exponential)
 * @return New taskpool instance
 */
parsec_taskpool_t*
hicma_parsec_sqrt_kernel_New(parsec_tiled_matrix_t *dcA, double rad,  double add_diag, int kernel) 
{
    parsec_taskpool_t* sqrt_kernel_taskpool;
    parsec_sqrt_kernel_taskpool_t* taskpool = NULL;

    /* Create new taskpool instance */
    taskpool = parsec_sqrt_kernel_new(dcA, rad, add_diag, kernel); 
    sqrt_kernel_taskpool = (parsec_taskpool_t*)taskpool;

    /* Set up arena for double data types */
    parsec_add2arena(&taskpool->arenas_datatypes[PARSEC_sqrt_kernel_DEFAULT_ADT_IDX],
                            parsec_datatype_double_t, PARSEC_MATRIX_FULL,
                            1, dcA->mb, dcA->nb, dcA->mb,
                            PARSEC_ARENA_ALIGNMENT_SSE, -1 );

    return sqrt_kernel_taskpool;
}

/**
 * @brief Destroy square root kernel taskpool
 * 
 * @param taskpool Taskpool to destroy
 */
void hicma_parsec_sqrt_kernel_Destruct(parsec_taskpool_t *taskpool)
{
    parsec_sqrt_kernel_taskpool_t *sqrt_kernel_taskpool = (parsec_sqrt_kernel_taskpool_t *)taskpool;
    
    /* Remove arena */
    parsec_del2arena(&sqrt_kernel_taskpool->arenas_datatypes[PARSEC_sqrt_kernel_DEFAULT_ADT_IDX]);
    
    /* Free taskpool */
    parsec_taskpool_free(taskpool);
}

/**
 * @brief Execute square root kernel operation
 * 
 * @param parsec PaRSEC context
 * @param dcA Input/output matrix descriptor
 * @param rad Radius parameter for kernel functions
 * @param add_diag Value to add to diagonal elements
 * @param kernel Kernel type selector (0=Gaussian, 1=Exponential)
 * @return 0 on success
 */
int hicma_parsec_sqrt_kernel(parsec_context_t *parsec, parsec_tiled_matrix_t *dcA, 
                            double rad, double add_diag, int kernel) 
{
    parsec_taskpool_t *parsec_sqrt_kernel = NULL;
    
    /* Create taskpool */
    parsec_sqrt_kernel = hicma_parsec_sqrt_kernel_New(dcA, rad, add_diag, kernel); 

    if( parsec_sqrt_kernel != NULL ){
        /* Execute taskpool */
        parsec_context_add_taskpool(parsec, parsec_sqrt_kernel);
        parsec_context_start(parsec);
        parsec_context_wait(parsec);
        
        /* Clean up */
        hicma_parsec_sqrt_kernel_Destruct(parsec_sqrt_kernel);
    }

    return 0;
}

%}

