extern "C" %{
/**
 * @copyright (c) 2023-2025     Saint Louis University (SLU)
 * @copyright (c) 2023-2025     Massachusetts Institute of Technology (MIT)
 * @copyright (c) 2023-2025     Nvidia Corporation
 * @copyright (c) 2018-2025     King Abdullah University of Science and Technology (KAUST)
 * @copyright (c) 2018-2023     The University of Tennessee and The University of Tennessee Research Foundation
 *                              All rights reserved.
 **/

#include "hicma_parsec.h"

%}

/**
 * @file reorder_gemm.jdf
 * @brief Reorder GEMM kernel for optimizing matrix multiplication order
 * 
 * This kernel implements a reordering strategy for GEMM operations to improve
 * computational efficiency. The reordering is based on matrix ranks and follows
 * different strategies for in-band vs off-band regions:
 * - In-band: maintains sequential order
 * - Off-band: reorders based on Arank from n_min (1) to n_max (n-reorder_gemm)
 */

/* Input/Output matrix descriptors and parameters */
descAr          [ type = "parsec_tiled_matrix_t *" ]  /* Input matrix A descriptor */
descRG          [ type = "parsec_tiled_matrix_t *" ]  /* Reorder matrix descriptor */
rank_array      [ type = "int *" ]                    /* Array containing matrix ranks */
disp            [ type = "int *" ]                    /* Displacement array */
nb_elem_r       [ type = "int *" ]                    /* Number of elements per rank */
band_size_dense [ type = "int" ]                      /* Size of dense band region */
reorder_gemm    [ type = "int" ]                      /* Reorder parameter for GEMM */
rows            [ type = "int" hidden = on default = "((parsec_matrix_block_cyclic_t *)descAr)->grid.rows" ]
cols            [ type = "int" hidden = on default = "((parsec_matrix_block_cyclic_t *)descAr)->grid.cols" ]
work_tmp        [ type = "parsec_memory_pool_t *" hidden = on default = NULL ]

/**
 * @brief Allocate memory for reorder matrix tiles
 * 
 * This task allocates memory for storing predecessor and successor information
 * for each tile in the reorder matrix.
 */
allocate(m, n)

// Execution space: upper triangular matrix tiles
m = 0 .. descRG->mt-1
n = 0 .. m

: descRG(m, n)

READ A <- NULL 

CTL ctl -> ctl1 gather_rank(m, n, 0 .. n-1)

BODY
{
    /* Allocate new data copy for reorder matrix tile */
    this_task->data._f_A.data_out = parsec_data_copy_new(data_of_descRG(m, n), 0, parsec_datatype_int_t, PARSEC_DATA_FLAG_PARSEC_MANAGED);

    /* Allocate memory for predecessor/successor arrays:
     * - First n elements: predecessor indices
     * - Next n elements: successor indices */
    this_task->data._f_A.data_out->device_private = calloc( 2*n, sizeof(int) );
}
END

/**
 * @brief Gather rank information for reordering decisions
 * 
 * This task collects rank information for each tile and determines the
 * reordering priority based on matrix ranks. Only processes off-band regions
 * where m-n >= band_size_dense.
 */
gather_rank(m, n, k) 

// Execution space: process tiles in off-band region
m = 2 .. descRG->mt-1
n = 1 .. m-1
k = 0 .. n-1

: descRG(m, n)

READ A <- descRG(m, n)

CTL ctl1 <- ctl allocate(m, n)
CTL ctl2 -> ctl reorder(m, n)

BODY
{
    /* Only process off-band regions (where matrix is not dense) */
    if( m-n >= band_size_dense ) {
        /* Extract rank information for current tile position */
        int Arank = rank_array[k*descAr->lm+m];
        int Brank = rank_array[k*descAr->lm+n];
        int Crank = rank_array[n*descAr->lm+m];

        /* Validate rank information */
        if( Arank < 0 || Brank < 0 || Crank < 0 ) {
            if( !(-1 == Brank && n-k < band_size_dense) )
            fprintf(stderr, "ERROR in reorder_gemm (%d, %d, %d): Arank %d, Brank %d, Crank %d\n", m, n, k, Arank, Brank, Crank);
        }

        /* Reordering policy: use minimum rank for priority
         * Note: B is dense if n < band_size_dense, so we use minimum rank
         * Alternative policies (commented out):
         * - Use Arank: ((int *)A)[k] = Arank;
         * - Use Brank: ((int *)A)[k] = Brank;
         * - Use maximum: ((int *)A)[k] = parsec_imax(Arank, Brank);
         * - Use sum: ((int *)A)[k] = Arank + Brank; */
        ((int *)A)[k] = parsec_imin(Arank, Brank);
    }
}
END

/**
 * @brief Reorder tiles based on rank information
 * 
 * This task performs the actual reordering of tiles based on the rank information
 * gathered in the previous step. It sorts tiles by rank and establishes predecessor/
 * successor relationships for the reordered sequence.
 */
reorder(m, n)

// Execution space: process tiles in off-band region
m = 2 .. descRG->mt-1
n = 1 .. m-1

: descRG(m, n)

READ A <- descRG(m, n)

CTL ctl <- ctl2 gather_rank(m, n, 0 .. n-1)

BODY
{
    /* Define reordering range: from n_min to n_max */
    int n_min = 1, n_max = n-reorder_gemm, tmp;
    int *buff = parsec_private_memory_pop(work_tmp);

    /* Initialize buffer with sequential order (0, 1, 2, ..., n-1) */
    for( int i = 0; i < n; i ++ )
        buff[i] = i;

#if DEBUG_INFO
    printf("actual_rank_order (%d, %d): ", m, n);
    for( int i = 0; i < n; i++ )
	    printf("%d ", ((int *)A)[i]);

    printf("\nlocation_before (%d, %d): ", m, n);
    for( int i = 0; i < n; i++ )
	    printf("%d ", buff[i]);
#endif

    /* Perform reordering if conditions are met */
    if( reorder_gemm > 1 && m-n >= band_size_dense ) {
        /* Bubble sort based on rank values (ascending order) */
        for( int i = n_min; i <= n_max; i++) {
            for( int j = i+1; j <= n_max; j++) {
                if( ((int *)A)[i] > ((int *)A)[j] ) {
                    /* Swap positions in buffer */
                    tmp = buff[i];
                    buff[i] = buff[j];
                    buff[j] = tmp;
                }
            }
        }
    }

#if DEBUG_INFO
    printf("\nlocation_after (%d, %d): ", m, n);
    for( int i = 0; i < n; i++ )
	    printf("%d ", buff[i]);
    printf("\n\n");
#endif

    /* Establish predecessor/successor relationships in reorder matrix */
    for( int i = 0; i < n; i ++ ) {
	    /* Set predecessor relationship */
	    if( 0 == i ) 
		    ((int *)PARSEC_DATA_COPY_GET_PTR(parsec_data_get_copy(data_of_descRG(m, n), 0)))[buff[i]] = -1;
	    else
		    ((int *)PARSEC_DATA_COPY_GET_PTR(parsec_data_get_copy(data_of_descRG(m, n), 0)))[buff[i]] = buff[i-1];

	    /* Set successor relationship */
	    if( n-1 == i ) 
		    ((int *)PARSEC_DATA_COPY_GET_PTR(parsec_data_get_copy(data_of_descRG(m, n), 0)))[buff[i]+n] = -1;
	    else
		    ((int *)PARSEC_DATA_COPY_GET_PTR(parsec_data_get_copy(data_of_descRG(m, n), 0)))[buff[i]+n] = buff[i+1];
    }

    /* Return buffer to memory pool */
    parsec_private_memory_push(work_tmp, buff);
}
END

extern "C" %{

/**
 * @brief Get predecessor index for reordered GEMM
 * 
 * @param descRG Reorder matrix descriptor
 * @param m Row index
 * @param n Column index  
 * @param k Element index
 * @return Predecessor index or -1 if not found
 */
int reorder_gemm_k_pre(parsec_tiled_matrix_t *descRG, int m, int n, int k) {
    if( descRG->super.myrank == descRG->super.rank_of(&descRG->super, m, n) ) {
        return ((int *)((descRG->super.data_of(&descRG->super, m, n))->device_copies[0]->device_private))[k];
    } else
        return -1;
}

/**
 * @brief Get successor index for reordered GEMM
 * 
 * @param descRG Reorder matrix descriptor
 * @param m Row index
 * @param n Column index
 * @param k Element index
 * @return Successor index or -1 if not found
 */
int reorder_gemm_k_next(parsec_tiled_matrix_t *descRG, int m, int n, int k) {
    if( descRG->super.myrank == descRG->super.rank_of(&descRG->super, m, n) ) {
        return ((int *)((descRG->super.data_of(&descRG->super, m, n))->device_copies[0]->device_private))[n+k];
    } else
        return -1;
}


/**
 * @brief Create new reorder GEMM taskpool
 * 
 * @param dcAr Input matrix descriptor
 * @param dcRG Reorder matrix descriptor
 * @param rank_array Array containing matrix ranks
 * @param disp Displacement array
 * @param nb_elem_r Number of elements per rank
 * @param band_size_dense Size of dense band region
 * @param reorder_gemm Reorder parameter for GEMM
 * @return New taskpool instance
 */
parsec_taskpool_t*
parsec_reorder_gemm_New(parsec_tiled_matrix_t *dcAr,
                        parsec_tiled_matrix_t *dcRG,
                        int *rank_array, int *disp,
                        int *nb_elem_r, int band_size_dense,
                        int reorder_gemm)
{
    parsec_taskpool_t* reorder_gemm_taskpool;
    parsec_reorder_gemm_taskpool_t* taskpool = NULL;

    /* Create new taskpool instance */
    taskpool = parsec_reorder_gemm_new(dcAr, dcRG, rank_array, disp, nb_elem_r,
                                       band_size_dense, reorder_gemm);
    reorder_gemm_taskpool = (parsec_taskpool_t*)taskpool;

    /* Initialize memory pool for temporary buffers */
    taskpool->_g_work_tmp = (parsec_memory_pool_t*)malloc(sizeof(parsec_memory_pool_t));
    parsec_private_memory_init( taskpool->_g_work_tmp, dcAr->lnt * sizeof(int) );

    /* Set up arena for integer data types */
    parsec_add2arena(&taskpool->arenas_datatypes[PARSEC_reorder_gemm_DEFAULT_ADT_IDX],
                            parsec_datatype_int_t, PARSEC_MATRIX_FULL,
                            1, dcRG->mb, dcRG->nb, dcRG->mb,
                            PARSEC_ARENA_ALIGNMENT_SSE, -1 );

    return reorder_gemm_taskpool;
}

/**
 * @brief Destroy reorder GEMM taskpool
 * 
 * @param taskpool Taskpool to destroy
 */
void parsec_reorder_gemm_Destruct(parsec_taskpool_t *taskpool)
{
    parsec_reorder_gemm_taskpool_t *reorder_gemm_taskpool = (parsec_reorder_gemm_taskpool_t *)taskpool;
    
    /* Clean up memory pool */
    parsec_private_memory_fini( reorder_gemm_taskpool->_g_work_tmp );
    
    /* Remove arena */
    parsec_del2arena(&reorder_gemm_taskpool->arenas_datatypes[PARSEC_reorder_gemm_DEFAULT_ADT_IDX]);
    
    /* Free taskpool */
    parsec_taskpool_free(taskpool);
}

/**
 * @brief Execute reorder GEMM operation
 * 
 * @param parsec PaRSEC context
 * @param dcAr Input matrix descriptor
 * @param dcRG Reorder matrix descriptor
 * @param rank_array Array containing matrix ranks
 * @param disp Displacement array
 * @param nb_elem_r Number of elements per rank
 * @param band_size_dense Size of dense band region
 * @param reorder_gemm Reorder parameter for GEMM
 * @return 0 on success
 */
int parsec_reorder_gemm(parsec_context_t *parsec,
                        parsec_tiled_matrix_t *dcAr,
                        parsec_tiled_matrix_t *dcRG,
                        int *rank_array, int *disp,
                        int *nb_elem_r, int band_size_dense,
                        int reorder_gemm)
{
    parsec_taskpool_t *parsec_reorder_gemm = NULL;
    
    /* Create taskpool */
    parsec_reorder_gemm = parsec_reorder_gemm_New(dcAr, dcRG, rank_array, disp, nb_elem_r,
                                                  band_size_dense, reorder_gemm);

    if( parsec_reorder_gemm != NULL ){
        /* Execute taskpool */
        parsec_context_add_taskpool(parsec, parsec_reorder_gemm);
        parsec_context_start(parsec);
        parsec_context_wait(parsec);
        
        /* Clean up */
        parsec_reorder_gemm_Destruct(parsec_reorder_gemm);
    }

    return 0;
}

%}
