extern "C" %{
/**
 * @copyright (c) 2023-2025     Saint Louis University (SLU)
 * @copyright (c) 2023-2025     Massachusetts Institute of Technology (MIT)
 * @copyright (c) 2023-2025     Nvidia Corporation
 * @copyright (c) 2018-2025     King Abdullah University of Science and Technology (KAUST)
 * @copyright (c) 2018-2023     The University of Tennessee and The University of Tennessee Research Foundation
 *                              All rights reserved.
 **/
#include "hicma_parsec.h"
#include <time.h>

/**
 * @brief IEEE 754 half-precision (16-bit) floating point union
 * 
 * This union allows access to the bit representation of half-precision floats
 * for manual conversion operations.
 */
typedef union FP16 {
    unsigned short u;  // Raw 16-bit representation
    struct {
        unsigned int Mantissa : 10;  // 10-bit mantissa
        unsigned int Exponent : 5;   // 5-bit exponent
        unsigned int Sign     : 1;   // 1-bit sign
    };
} FP16;

/**
 * @brief IEEE 754 single-precision (32-bit) floating point union
 * 
 * This union allows access to the bit representation of single-precision floats
 * for manual conversion operations.
 */
typedef union FP32 {
    unsigned int u;  // Raw 32-bit representation
    float f;         // Float value
    struct {
        unsigned int Mantissa : 23;  // 23-bit mantissa
        unsigned int Exponent : 8;   // 8-bit exponent
        unsigned int Sign     : 1;   // 1-bit sign
    };
} FP32;

/**
 * @brief IEEE 754 double-precision (64-bit) floating point union
 * 
 * This union allows access to the bit representation of double-precision floats
 * for manual conversion operations.
 */
typedef union FP64 {
    uint64_t u;  // Raw 64-bit representation
    double f;    // Double value
    struct {
        uint64_t Mantissa : 52;  // 52-bit mantissa
        uint64_t Exponent : 11;  // 11-bit exponent
        uint64_t Sign     : 1;   // 1-bit sign
    };
} FP64;

/**
 * @brief Convert half-precision (FP16) to double-precision (FP64) floating point
 * 
 * This function performs manual bit-level conversion from IEEE 754 half-precision
 * to double-precision format, handling special cases like zero, infinity, and denormalized numbers.
 * 
 * @param [in] h: the half-precision float to convert
 * @return the converted double-precision value
 */
static double half_to_double(FP16 h) {
    FP64 d;
    unsigned int sign = h.Sign;    // Extract sign bit
    int exp = h.Exponent;          // Extract exponent
    unsigned int mant = h.Mantissa; // Extract mantissa
    
    if(exp == 0) {
        // Handle zero or denormalized numbers
        if(mant == 0) {
            // Zero: set sign bit only
            d.u = ((uint64_t)sign << 63);
        } else {
            // Denormalized: normalize the mantissa and adjust exponent
            while((mant & 0x0400) == 0) {
                mant <<= 1;
                exp--;
            }
            exp++;
            mant &= 0x03FF;
            // Convert to double-precision exponent bias
            int new_exp = exp + (1023 - 15);
            d.u = ((uint64_t)sign << 63) | ((uint64_t)new_exp << 52) | ((uint64_t)mant << (52 - 10));
        }
    } else if(exp == 31) {
        // Handle infinity or NaN
        d.u = ((uint64_t)sign << 63) | ((uint64_t)0x7FF << 52) | ((uint64_t)mant << (52 - 10));
    } else {
        // Normal numbers: convert exponent bias from FP16 to FP64
        int new_exp = exp - 15 + 1023;
        d.u = ((uint64_t)sign << 63) | ((uint64_t)new_exp << 52) | ((uint64_t)mant << (52 - 10));
    }
    return d.f;
}

/**
 * @brief Copy and convert matrix data to double precision
 * 
 * This function copies data from a source matrix to a destination matrix,
 * converting the data type to double precision based on the decision map.
 * Supports conversion from double, single, and half precision to double precision.
 * 
 * @param [in] A: source matrix data (void pointer for different types)
 * @param [out] B: destination matrix (double precision)
 * @param [in] mb: number of rows in the tile
 * @param [in] nb: number of columns in the tile
 * @param [in] nt: total number of column tiles (unused)
 * @param [in] lda: leading dimension of the source matrix
 * @param [in] m: tile row index (unused)
 * @param [in] n: tile column index (unused)
 * @param [in] decision_map: type of the source data (DENSE_DP, DENSE_SP, DENSE_HP)
 * @param [in] params_tlr: TLR parameters (unused)
 */
void copy_2_double(void *A, double *B, int mb, int nb, int nt, int lda, int m, int n, uint16_t decision_map, hicma_parsec_params_t *params_tlr){
    double *b = B;
    switch(decision_map){
        case DENSE_DP:{
            // Source is already double precision - direct copy
            double *a_type = A;
            for(int i = 0; i < mb; i++){
                for(int j = 0; j < nb; j++){
                    b[j*lda+i] = a_type[j*lda+i];
                }
            }
            break;
        }    
            
        
        case DENSE_SP:{
            // Source is single precision - cast to double
            float *a_type = A;
            for(int i = 0; i < mb; i++){
                for(int j = 0; j < nb; j++){
                    b[j*lda+i] = (double)a_type[j*lda+i];
                }
            }
            break;
        }

        case DENSE_HP:{
            // Source is half precision - convert using bit manipulation
            FP16 h;
            uint16_t *a_type = A;
            for(int i = 0; i < mb; i++){
                for(int j = 0; j < nb; j++){
                    h.u = a_type[j * lda + i];
                    b[j * lda + i] = half_to_double(h);
                }
            }
            break;
        }
    }   
}


%}


// Task parameters for copy to double operation
descA           [ type = "parsec_tiled_matrix_t*" ]     // Source matrix descriptor
descB           [ type = "parsec_tiled_matrix_t*" aligned = descA]  // Destination matrix descriptor (aligned with source)
decision_map    [ type = "uint16_t* " ]                // Map indicating data type for each tile
params_tlr      [ type = "hicma_parsec_params_t *" ]   // TLR parameters

/**************************************************
 *                 COPY2DOUBLE                    *
 * Copy matrix tiles from source to destination  *
 * with conversion to double precision           *
 **************************************************/

/**
 * @brief PaRSEC task for copying and converting matrix tiles to double precision
 * 
 * This task copies data from source matrix A to destination matrix B,
 * converting the data type to double precision based on the decision map.
 * Each tile may have a different source data type (double, single, or half precision).
 */
COPY2DOUBLE(m, n)

// Iteration space: process all tiles in the matrix
m = 0 .. descA->mt-1
n = 0 .. descA->nt-1

// Data dependency: read from source, write to destination
: descB(m, n)

// Read access to source matrix tile
READ A <- descA(m, n)    

// Read-write access to destination matrix tile
RW B <- descB(m, n) 
        -> descB(m, n)     

BODY
{
    // Calculate actual tile dimensions (handle edge tiles)
    int tempmm, tempnn, ldam, ldbm;
    int i, j;
    
    // Actual number of rows in this tile (handle last tile in column)
    tempmm = ((m)==((descA->mt)-1)) ? ((descA->m)-(m*(descA->mb))) : (descA->mb);
    // Actual number of columns in this tile (handle last tile in row)
    tempnn = ((n)==((descA->nt)-1)) ? ((descA->n)-(n*(descA->nb))) : (descA->nb);
    // Leading dimension of the source tile
    ldam = BLKLDD( descA, m );

    // Copy and convert the tile data to double precision
    // The decision map indicates the source data type for this specific tile
    copy_2_double(A, B, tempmm, tempnn, descA->nt, ldam, m, n, decision_map[n * descA->mt + m], params_tlr);
}
END



extern "C" %{

    /**
     * @brief Create a new copy-to-double taskpool
     * 
     * This function creates a PaRSEC taskpool that copies data from source matrix A
     * to destination matrix B, converting all data to double precision based on
     * the decision map that indicates the source data type for each tile.
     *
     * @param [in] A: source matrix, already distributed and allocated
     * @param [in] decision_map: map indicating data type for each tile
     * @param [in] B: destination matrix for double precision data
     * @param [in] params: TLR parameters
     * @return the parsec object to schedule
     */
    parsec_taskpool_t*
        parsec_copy2double_New(parsec_tiled_matrix_t *A, uint16_t* decision_map, parsec_tiled_matrix_t *B, hicma_parsec_params_t *params) 
        {
            parsec_taskpool_t* band_copy2double_taskpool;
            parsec_copy2double_taskpool_t* taskpool = NULL;

            // Create the taskpool with the given parameters
            taskpool = parsec_copy2double_new(A, B, decision_map, params);
            band_copy2double_taskpool = (parsec_taskpool_t*)taskpool;

            return band_copy2double_taskpool;
        }

    /**
     * @brief Destroy the copy-to-double taskpool and free associated resources
     * @param [inout] taskpool: the parsec object to destroy
     */
    void parsec_copy2double_Destruct(parsec_taskpool_t *taskpool)
    {
        parsec_copy2double_taskpool_t *copy2double_taskpool = (parsec_copy2double_taskpool_t *)taskpool;
        
        // Free the taskpool memory
        parsec_taskpool_free(taskpool);
    }

/**
 * @brief Copy matrix data to double precision with type conversion
 * 
 * This function copies data from source matrix A to destination matrix B,
 * converting all data to double precision based on the decision map.
 * Each tile may have a different source data type (double, single, or half precision).
 * 
 * @param [in] parsec: the PaRSEC context
 * @param [in] A: source matrix, already distributed and allocated
 * @param [in] decision_map: map indicating data type for each tile
 * @param [in] B: destination matrix for double precision data
 * @param [in] params: TLR parameters
 * @return 0 on success
 */
int parsec_copy2double(parsec_context_t *parsec,
        parsec_tiled_matrix_t *A,
        uint16_t* decision_map,
        parsec_tiled_matrix_t *B,
        hicma_parsec_params_t *params) 
{
    parsec_taskpool_t *parsec_copy2double = NULL;

    // Create and execute the copy-to-double taskpool
    parsec_copy2double = parsec_copy2double_New(A, decision_map, B, params);
    if( parsec_copy2double != NULL ){
        parsec_context_add_taskpool(parsec, parsec_copy2double);
        parsec_context_start(parsec);
        parsec_context_wait(parsec);
        parsec_copy2double_Destruct(parsec_copy2double);
    }
    return 0;
}

%}
