extern "C" %{
/**
 * @copyright (c) 2023-2025     Saint Louis University (SLU)
 * @copyright (c) 2023-2025     Massachusetts Institute of Technology (MIT)
 * @copyright (c) 2023-2025     Nvidia Corporation
 * @copyright (c) 2023-2025     King Abdullah University of Science and Technology (KAUST)
 * @copyright (c) 2018-2023     The University of Tennessee and The University of Tennessee Research Foundation
 *                              All rights reserved.
 **/

#include "climate_emulator.h"

/**
 * @brief Compute the maximum absolute difference between two double matrices
 * 
 * This function calculates the element-wise absolute difference between matrices A and B,
 * returning the maximum difference found. It includes early termination if the difference
 * exceeds a threshold (1.0e-4) for efficiency.
 * 
 * @param A First matrix (reference data)
 * @param B Second matrix (data to compare against)
 * @param M Number of rows in the matrices
 * @param N Number of columns in the matrices
 * @return Maximum absolute difference found, or early termination value if threshold exceeded
 */
static double diff_double_core(double *A, double *B, int M, int N) {
    double result = 0.0;
    
    // Iterate through all elements of the matrices
    for (int j = 0; j < N; j++) {
        for (int i = 0; i < M; i++) {
            // Compute absolute difference between corresponding elements
            result = fmax(result, fabs(A[j*M+i]-B[j*M+i]));
            
            // Early termination if difference exceeds threshold
            if( result > 1.0e-4 ) {
#if DEBUG_INFO_CLIMATE_EMULATOR
                // Print detailed error information in debug mode
                printf("DIFF_ERROR %d %d : %.16lf %.16lf\n", i, j, A[j*M+i], B[j*M+i]);
#endif
                return result;
            }
        }
    }
    return result;
}

%}

/* Matrix descriptors for the two matrices to be compared */
descA         [ type = "parsec_tiled_matrix_t*" ]
descB         [ type = "parsec_tiled_matrix_t*" aligned = descA ]

/* Task definition for computing differences between matrix tiles
 * Each task processes one tile (m, n) from both matrices
 */
task(m, n)

m = 0 .. descA->lmt-1
n = 0 .. descA->lnt-1 

: descA(m, n)

READ A <- descA(m, n) 
READ B <- descB(m, n) 

BODY
{
    // Compute the maximum difference between corresponding tiles
    double diff = diff_double_core(A, B, descA->mb, descA->nb);
    
#if DEBUG_INFO_CLIMATE_EMULATOR
    // Print difference information for debugging
    printf("DIFF m %d n %d mb %d nb %d : %.16le\n", m, n, descA->mb, descA->nb, diff);
#endif
}
END

extern "C" %{

/**
 * @brief Create and initialize a new PaRSEC taskpool for matrix difference computation
 * 
 * This function sets up the taskpool with two matrix descriptors and configures
 * the arena for double precision data types. It also verifies that both matrices
 * have compatible tile dimensions.
 * 
 * @param parsec PaRSEC context
 * @param descA Descriptor for the first matrix
 * @param descB Descriptor for the second matrix
 * @return Pointer to the initialized taskpool
 */
parsec_taskpool_t*
climate_emulator_diff_double_New(parsec_context_t *parsec,
        parsec_matrix_block_cyclic_t *descA,
        parsec_matrix_block_cyclic_t *descB)
{
    // Verify that both matrices have the same tile dimensions for comparison
    assert(descA->super.mb == descB->super.mb);
    assert(descA->super.nb == descB->super.nb);
    
    // Create the difference computation taskpool
    parsec_climate_emulator_diff_double_taskpool_t *taskpool = parsec_climate_emulator_diff_double_new(&descA->super, &descB->super);
    
    // Configure the arena for double precision data types
    parsec_add2arena(&taskpool->arenas_datatypes[PARSEC_climate_emulator_diff_double_DEFAULT_ADT_IDX],
                            parsec_datatype_double_t, PARSEC_MATRIX_FULL,
                            1, descA->super.mb, descA->super.nb, descA->super.mb,
                            PARSEC_ARENA_ALIGNMENT_SSE, -1 );

    return (parsec_taskpool_t*)taskpool;
}

/**
 * @brief Clean up and destroy the PaRSEC difference computation taskpool
 * 
 * This function properly deallocates the arena and the taskpool itself
 * to prevent memory leaks.
 * 
 * @param taskpool Pointer to the taskpool to destroy
 */
void climate_emulator_diff_double_Destruct(parsec_taskpool_t *taskpool)
{
    parsec_climate_emulator_diff_double_taskpool_t *climate_emulator_diff_double_taskpool = (parsec_climate_emulator_diff_double_taskpool_t *)taskpool;
    
    // Remove the arena for double precision data types
    parsec_del2arena(&climate_emulator_diff_double_taskpool->arenas_datatypes[PARSEC_climate_emulator_diff_double_DEFAULT_ADT_IDX]);
    
    // Free the taskpool itself
    parsec_taskpool_free(taskpool);
}

/**
 * @brief Main function to execute matrix difference computation
 * 
 * This function orchestrates the entire difference computation process:
 * 1. Creates and configures the difference computation taskpool
 * 2. Executes the difference computations in parallel across all tiles
 * 3. Waits for completion and cleans up resources
 * 
 * @param parsec PaRSEC context
 * @param descA Descriptor for the first matrix
 * @param descB Descriptor for the second matrix
 * @return 0 on success
 */
int climate_emulator_diff_double(parsec_context_t *parsec,
        parsec_matrix_block_cyclic_t *descA,  
        parsec_matrix_block_cyclic_t *descB)
{
    // Create the difference computation taskpool
    parsec_taskpool_t *parsec_climate_emulator_diff_double = NULL;
    parsec_climate_emulator_diff_double = climate_emulator_diff_double_New( parsec, descA, descB);
    
    if( parsec_climate_emulator_diff_double != NULL ){
        // Add the taskpool to the PaRSEC context
        parsec_context_add_taskpool(parsec, parsec_climate_emulator_diff_double);
        
        // Start execution of all difference computation tasks
        parsec_context_start(parsec);
        
        // Wait for all tasks to complete
        parsec_context_wait(parsec);
        
        // Clean up the taskpool
        climate_emulator_diff_double_Destruct(parsec_climate_emulator_diff_double);
    }

    return 0;
}

%}
