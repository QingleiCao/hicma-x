extern "C" %{
/**
 * @copyright (c) 2023-2025     Saint Louis University (SLU)
 * @copyright (c) 2023-2025     Massachusetts Institute of Technology (MIT)
 * @copyright (c) 2023-2025     Nvidia Corporation
 * @copyright (c) 2023-2025     King Abdullah University of Science and Technology (KAUST)
 * @copyright (c) 2018-2023     The University of Tennessee and The University of Tennessee Research Foundation
 *                              All rights reserved.
 **/

#include "climate_emulator.h"

/**
 * @brief Compute the normalized root mean square error (RMSE) between two matrices
 * 
 * This function calculates the RMSE between a complex double matrix A and a real double matrix B.
 * The error is normalized by the factor 2*L*(L+1) where L is the spherical harmonic degree.
 * 
 * @param A Complex double matrix (reference data)
 * @param B Real double matrix (approximated data)
 * @param M Number of rows in the matrices
 * @param N Number of columns in the matrices
 * @param L Spherical harmonic degree for normalization
 * @return Normalized RMSE value
 */
static double norm_core(complex double *A, double *B, int M, int N, int L) {
    double result = 0.0, diff;
    
    // Iterate through all elements of the matrices
    for(int j = 0; j < N; j++) {
        for(int i = 0; i < M; i++) {
            // Compute difference between complex and real values
            // Take only the real part of the complex number
            double diff = creal(A[j*M+i]) - B[j*M+i];
            // Accumulate squared differences
            result += diff * diff;
        }
    }
    
    // Return normalized RMSE: sqrt(sum of squared differences) / normalization_factor
    return sqrt(result) / (2*L*(L+1));
}

%}

/* Matrix descriptors for PaRSEC task scheduling
 * These define the data dependencies between tasks
 */
desc_f_data       [ type = "parsec_tiled_matrix_t*" ]
desc_f_spatial    [ type = "parsec_tiled_matrix_t*" aligned = desc_f_data ]
gb                [ type = "climate_emulator_struct_t*" ]

/* Task definition for computing MSE between corresponding tiles
 * Each task processes one column (n) of the matrices
 */
task(n)

n = 0 .. desc_f_data->lnt-1 

: desc_f_data(0, n)

READ f_data    <- desc_f_data(0, n)         [ type = f_data ] 
READ f_spatial <- desc_f_spatial(0, n)      [ type = f_spatial ] 

BODY
{
    // Compute the normalized RMSE between the current tile of f_data and f_spatial
    double norm = norm_core(f_data, f_spatial, desc_f_data->mb, desc_f_data->nb, gb->L);
    if(gb->verbose > 1) printf("MSE of time_slot %d : %lf\n", n, norm);
}
END

extern "C" %{

/**
 * @brief Create and initialize a new PaRSEC taskpool for MSE computation
 * 
 * This function sets up the taskpool with matrix descriptors and configures
 * the arenas for complex double and real double data types.
 * 
 * @param parsec PaRSEC context
 * @param gb Climate emulator structure
 * @param params HICMA parameters
 * @return Pointer to the initialized taskpool
 */
parsec_taskpool_t*
climate_emulator_mse_New(parsec_context_t *parsec,
        climate_emulator_struct_t *gb,
        hicma_parsec_params_t *params)
{
    // Verify that both matrices have the same tile dimensions
    assert(gb->desc_f_data.super.mb == gb->desc_f_spatial.super.mb);
    assert(gb->desc_f_data.super.nb == gb->desc_f_spatial.super.nb);
    
    int mb = gb->desc_f_data.super.mb;
    int nb = gb->desc_f_data.super.nb;
    
    // Create the MSE taskpool with the matrix descriptors
    parsec_climate_emulator_mse_taskpool_t *taskpool = parsec_climate_emulator_mse_new(&gb->desc_f_data.super, &gb->desc_f_spatial.super, gb);

    // Configure arena for complex double data type (f_data matrix)
    parsec_add2arena(&taskpool->arenas_datatypes[PARSEC_climate_emulator_mse_f_data_ADT_IDX],
                            parsec_datatype_double_complex_t, PARSEC_MATRIX_FULL,
                            1, mb, nb, mb,
                            PARSEC_ARENA_ALIGNMENT_SSE, -1 );

    // Configure arena for real double data type (f_spatial matrix)
    parsec_add2arena(&taskpool->arenas_datatypes[PARSEC_climate_emulator_mse_f_spatial_ADT_IDX],
                            parsec_datatype_double_t, PARSEC_MATRIX_FULL,
                            1, mb, nb, mb,
                            PARSEC_ARENA_ALIGNMENT_SSE, -1 );

    return (parsec_taskpool_t*)taskpool;
}

/**
 * @brief Clean up and destroy the PaRSEC MSE taskpool
 * 
 * This function properly deallocates all arenas and the taskpool itself
 * to prevent memory leaks.
 * 
 * @param taskpool Pointer to the taskpool to destroy
 */
void climate_emulator_mse_Destruct(parsec_taskpool_t *taskpool)
{
    parsec_climate_emulator_mse_taskpool_t *climate_emulator_mse_taskpool = (parsec_climate_emulator_mse_taskpool_t *)taskpool;
    
    // Remove the arena for complex double data types
    parsec_del2arena(&climate_emulator_mse_taskpool->arenas_datatypes[PARSEC_climate_emulator_mse_f_data_ADT_IDX]);
    
    // Remove the arena for real double data types
    parsec_del2arena(&climate_emulator_mse_taskpool->arenas_datatypes[PARSEC_climate_emulator_mse_f_spatial_ADT_IDX]);
    
    // Free the taskpool itself
    parsec_taskpool_free(taskpool);
}

/**
 * @brief Main function to execute the MSE computation
 * 
 * This function orchestrates the entire MSE computation process:
 * 1. Creates and configures the MSE taskpool
 * 2. Executes the MSE computations in parallel across all tiles
 * 3. Waits for completion and cleans up resources
 * 
 * @param parsec PaRSEC context
 * @param gb Climate emulator structure
 * @param params HICMA parameters
 * @return 0 on success
 */
int climate_emulator_mse(parsec_context_t *parsec,
        climate_emulator_struct_t *gb,
        hicma_parsec_params_t *params)
{
    // Create the MSE taskpool
    parsec_taskpool_t *parsec_climate_emulator_mse = NULL;
    parsec_climate_emulator_mse = climate_emulator_mse_New(parsec, gb, params);
    
    if( parsec_climate_emulator_mse != NULL ){
        // Add the taskpool to the PaRSEC context
        parsec_context_add_taskpool(parsec, parsec_climate_emulator_mse);
        
        // Start execution of all tasks
        parsec_context_start(parsec);
        
        // Wait for all tasks to complete
        parsec_context_wait(parsec);
        
        // Clean up the taskpool
        climate_emulator_mse_Destruct(parsec_climate_emulator_mse);
    }

    return 0;
}

%}
